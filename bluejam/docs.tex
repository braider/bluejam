\documentclass[11pt]{report}
\def\bl{\mbox{}\newline\mbox{}\newline{}}
\usepackage{ifthen}
\newcommand{\hide}[2]{
\ifthenelse{\equal{#1}{inherited}}%
{}%
{}%
}
\newcommand{\entityintro}[3]{%
  \hbox to \hsize{%
    \vbox{%
      \hbox to .2in{}%
    }%
    {\bf #1}%
    \dotfill\pageref{#2}%
  }
  \makebox[\hsize]{%
    \parbox{.4in}{}%
    \parbox[l]{5in}{%
      \vspace{1mm}\it%
      #3%
      \vspace{1mm}%
    }%
  }%
}
\newcommand{\isep}[0]{%
\setlength{\itemsep}{-.4ex}
}
\newcommand{\sld}[0]{%
\setlength{\topsep}{0em}
\setlength{\partopsep}{0em}
\setlength{\parskip}{0em}
\setlength{\parsep}{-1em}
}
\newcommand{\headref}[3]{%
\ifthenelse{#1 = 1}{%
\addcontentsline{toc}{section}{\hspace{\qquad}\protect\numberline{}{#3}}%
}{}%
\ifthenelse{#1 = 2}{%
\addcontentsline{toc}{subsection}{\hspace{\qquad}\protect\numerline{}{#3}}%
}{}%
\ifthenelse{#1 = 3}{%
\addcontentsline{toc}{subsubsection}{\hspace{\qquad}\protect\numerline{}{#3}}%
}{}%
\label{#3}%
\makebox[\textwidth][l]{#2 #3}%
}%
\newcommand{\membername}[1]{{\it #1}\linebreak}
\newcommand{\divideents}[1]{\vskip -1em\indent\rule{2in}{.5mm}}
\newcommand{\refdefined}[1]{
\expandafter\ifx\csname r@#1\endcsname\relax
\relax\else
{$($ in \ref{#1}, page \pageref{#1}$)$}
\fi}
\newcommand{\startsection}[4]{
\gdef\classname{#2}
\subsection{\label{#3}{\bf {\sc #1} #2}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\vskip .1in 
#4
}%
}
\newcommand{\startsubsubsection}[2]{
\subsubsection{\sc #1}{%
\rule[1em]{\hsize}{2pt}%
#2}
}
\usepackage{color}
\date{\today}
\pagestyle{myheadings}
\addtocontents{toc}{\protect\def\protect\packagename{}}
\addtocontents{toc}{\protect\def\protect\classname{}}
\markboth{\protect\packagename -- \protect\classname}{\protect\packagename -- \protect\classname}
\oddsidemargin 0in
\evensidemargin 0in
% \topmargin -.8in
\chardef\bslash=`\\
\textheight 9.4in
\textwidth 6.5in
\title{BlueJam :: Core Package Documentation	}
\begin{document}
\maketitle
\sloppy
\raggedright
\tableofcontents
\gdef\packagename{}
\gdef\classname{}
\newpage
\def\packagename{net.parallaxed.bluejam.playback}
\chapter{\bf Package net.parallaxed.bluejam.playback}{
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Interfaces}
\entityintro{Listener}{l0}{This interface can be implemented by classes that
 wish to receive notifications from evolving populations.}
\entityintro{Player}{l1}{This interface is implemented by classes that produce output
 (default: Evolve).}
\entityintro{Saveable}{l2}{Returns a stringed version of this note compatible
 with the heuristic format.}
\vskip .13in
\hbox{\bf Classes}
\entityintro{MIDI}{l3}{This is a static class used primarily for converting
 internal note representations into MIDI numbers
 and vice versa.}
\entityintro{MIDI.GREATER\_THAN}{l4}{...no description...}
\entityintro{MIDI.LESS\_THAN}{l5}{...no description...}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
\newpage
\section{Interfaces}{
\startsection{Interface}{Listener}{l0}{%
{\small This interface can be implemented by classes that
 wish to receive notifications from evolving populations.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
Listener}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{listen}
{\tt public void {\bf listen}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l6}\label{l7}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Called by the Evolving population when a candidate
 NoteSequence is ready to be played.
 
 A null noteSequence should be passed when no more
 generations will be calculated.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The NoteSequence to be played.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{Player}{l1}{%
{\small This interface is implemented by classes that produce output
 (default: Evolve). These classes should run in their own threads
 and output NoteSequences to subscribed listeners.
 
 Ideally, they should change their behaviour based on an
 established protocol for exchanging feedback between it's
 listeners.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
Player}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{addListener}
{\tt public void {\bf addListener}( {\tt net.parallaxed.bluejam.playback.Listener } {\bf listener} )
\label{l8}\label{l9}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
A listener (class implementing the Listener interface), must call this
 method to register with the player that it wishes to receive calls to
 it's listen() method, with various NoteSequences.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt listener} - A reference to the registering listener (normally *this*).}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{feedback}
\item{\vskip -1.9ex 
\membername{feedback}
{\tt public void {\bf feedback}( {\tt int } {\bf feedback},
{\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l10}\label{l11}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method can be called by listeners to provide an integer value
 (most simply, -1, 0 or +1), for the purpose of informing the player
 what that listener thought of the NoteSequence supplied.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt feedback} - An integer value denoting the perceived quality of the NoteSeqeunce}
   \item{
\sld
{\tt notes} - The NoteSequence we're feeding back on.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{Saveable}{l2}{%
{\small Returns a stringed version of this note compatible
 with the heuristic format.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
Saveable}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{stringify}
{\tt public String {\bf stringify}(  )
\label{l12}\label{l13}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
}
\section{Classes}{
\startsection{Class}{MIDI}{l3}{%
{\small This is a static class used primarily for converting
 internal note representations into MIDI numbers
 and vice versa.
 
 This class can discover if a particular pitch is relatively
 higher or lower than another given pitch, in the context
 of a single MIDI defined octave
 
 (this does not work for notes spanning multiple octaves
 ...yet)
 
 These values can be used at playback time.
 
 TODO HIGH Uses a convoluted algorithm of O(n), simply cycling through the array - could be vastly improved.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
MIDI}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{MIDI}
{\tt public {\bf MIDI}(  )
\label{l14}\label{l15}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{noteToNumber}
{\tt public static float {\bf noteToNumber}( {\tt net.parallaxed.bluejam.Note } {\bf n} )
\label{l16}\label{l17}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method will return a MIDI number for the given 
 note. This method DOES NOT validate that MIDI number
 (should be 0 \textless = n \textless = 127).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The note to calculate for.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A MIDI number for the note. 
}%end item
\end{itemize}
}%end item
\divideents{numberToNote}
\item{\vskip -1.9ex 
\membername{numberToNote}
{\tt public static Note {\bf numberToNote}( {\tt float } {\bf noteNumber} )
\label{l18}\label{l19}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Currently used by the Configure class in the PD
 implementation to tell what note is being set as the
 root pitch.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt noteNumber} - }
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A Note instance configured to reflect the passed number. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.Note} {\small 
\refdefined{l20}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{position}
\item{\vskip -1.9ex 
\membername{position}
{\tt public static int {\bf position}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitch1} )
\label{l21}\label{l22}}%end signature
}%end item
\divideents{relative}
\item{\vskip -1.9ex 
\membername{relative}
{\tt public static Pitch {\bf relative}( {\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf relativeIndex} )
\label{l23}\label{l24}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{MIDI.GREATER\_THAN}{l4}{%
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static 
class 
MIDI.GREATER\_THAN}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{MIDI.GREATER\_THAN}
{\tt public {\bf MIDI.GREATER\_THAN}(  )
\label{l25}\label{l26}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public boolean {\bf eval}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitch1},
{\tt net.parallaxed.bluejam.Pitch } {\bf pitch2} )
\label{l27}\label{l28}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{MIDI.LESS\_THAN}{l5}{%
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static 
class 
MIDI.LESS\_THAN}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{MIDI.LESS\_THAN}
{\tt public {\bf MIDI.LESS\_THAN}(  )
\label{l29}\label{l30}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public static boolean {\bf eval}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitch1},
{\tt net.parallaxed.bluejam.Pitch } {\bf pitch2} )
\label{l31}\label{l32}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
}
}
\newpage
\def\packagename{net.parallaxed.bluejam.grammar}
\chapter{\bf Package net.parallaxed.bluejam.grammar}{
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Classes}
\entityintro{ModelParser}{l33}{This class parses flat-file Markov models which can be used 
 by sets during the selection process to assign proportionate
 probabilities to possible notes in the scale.}
\entityintro{PitchModel}{l34}{The PitchModel class represents a 1-order Markov model 
 describing a probability matrix of Pitches.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
\newpage
\section{Classes}{
\startsection{Class}{ModelParser}{l33}{%
{\small This class parses flat-file Markov models which can be used 
 by sets during the selection process to assign proportionate
 probabilities to possible notes in the scale.
 
 Models describe what's likely to happen given note X has 
 already happened.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
ModelParser}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{ModelParser}
{\tt public {\bf ModelParser}( {\tt java.io.File } {\bf modelFile} )
\label{l35}\label{l36}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a ModelParser. Use getModel() to extract
 the parsed model.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt modelFile} - A reference to a File object for the model file.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ModelParser}
\item{\vskip -1.9ex 
\membername{ModelParser}
{\tt public {\bf ModelParser}( {\tt java.lang.String } {\bf modelFile} )
\label{l37}\label{l38}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a ModelParser. Use getModel() to extract
 the parsed model.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt modelFile} - The absolute path to the model file.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getModel}
{\tt public PitchModel {\bf getModel}(  )
\label{l39}\label{l40}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The model that has been parsed by this ModelParser, or null if no Model has been parsed. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{PitchModel}{l34}{%
{\small The PitchModel class represents a 1-order Markov model 
 describing a probability matrix of Pitches. The model is a 
 lookup table that will return P(X|Y), where X and Y are a set 
 of notes in a given context. For more complex models, this 
 class could be written to include support for cases where Y 
 is a series of notes, increasing the order of the model
 up to the number of notes in Y. 
 
 Models must be locked after loading before use, such that no further
 changes can be made to a model, and the model is deemed valid.
 
 Please see additional documentation and the technical report
 for information regarding pitch models.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
PitchModel}}
\noindent\hbox{\vbox{{\bf extends} java.util.HashMap}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private String \_name\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
private boolean \_editable\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
private ArrayList \_pitchOrder\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
private PitchModel \_original\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{PitchModel}
{\tt public {\bf PitchModel}( {\tt java.lang.String } {\bf name} )
\label{l41}\label{l42}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Creates a PitchModel instance.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{get}
{\tt public double {\bf get}( {\tt net.parallaxed.bluejam.Pitch } {\bf key} )
\label{l43}\label{l44}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt key} - The pitch to return the model for.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The model for the given pitch. 
}%end item
\end{itemize}
}%end item
\divideents{getPitch}
\item{\vskip -1.9ex 
\membername{getPitch}
{\tt public Pitch {\bf getPitch}( {\tt int } {\bf index} )
\label{l45}\label{l46}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Pitch order is preserved when adding to the model. Models 
 remain square matrices, for every new pitch, a new row and
 new column is appended to the table.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The index sought.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The pitch at the passed index of the model 
}%end item
\end{itemize}
}%end item
\divideents{put}
\item{\vskip -1.9ex 
\membername{put}
{\tt public double {\bf put}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitch},
{\tt double []} {\bf model} )
\label{l47}\label{l48}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Adds a single pitch, giving the probability series for other
 notes in the model following that pitch. This function will
 replace any existing pitches matching the passed pitch. The model
 must be editable to make changes.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitch} - The pitch to add.}
   \item{
\sld
{\tt model} - The matrix of probabilities to append to the model for that pitch.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The model matrix that was replaced, if any. 
}%end item
\end{itemize}
}%end item
\divideents{putAll}
\item{\vskip -1.9ex 
\membername{putAll}
{\tt public double {\bf putAll}( {\tt java.util.Map } {\bf m} )
\label{l49}\label{l50}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Puts a Map of notes into the model.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m} - The map to add to the model}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The last model replaced, if any. 
}%end item
\end{itemize}
}%end item
\divideents{validateModel}
\item{\vskip -1.9ex 
\membername{validateModel}
{\tt public void {\bf validateModel}(  )
\label{l51}\label{l52}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Protected call to the internal \_validateModel()
 
 This method locks the model if validation is successful.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.util.HashMap}}{
\par{\small 
\refdefined{l53}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public Object {\bf clone}(  )
}%end signature
}%end item
\divideents{containsKey}
\item{\vskip -1.9ex 
\membername{containsKey}
{\tt public boolean {\bf containsKey}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsValue}
\item{\vskip -1.9ex 
\membername{containsValue}
{\tt public boolean {\bf containsValue}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{entrySet}
\item{\vskip -1.9ex 
\membername{entrySet}
{\tt public Set {\bf entrySet}(  )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Object {\bf get}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{keySet}
\item{\vskip -1.9ex 
\membername{keySet}
{\tt public Set {\bf keySet}(  )
}%end signature
}%end item
\divideents{put}
\item{\vskip -1.9ex 
\membername{put}
{\tt public Object {\bf put}( {\tt java.lang.Object } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{putAll}
\item{\vskip -1.9ex 
\membername{putAll}
{\tt public void {\bf putAll}( {\tt java.util.Map } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public Collection {\bf values}(  )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractMap}}{
\par{\small 
\refdefined{l54}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected Object {\bf clone}(  )
}%end signature
}%end item
\divideents{containsKey}
\item{\vskip -1.9ex 
\membername{containsKey}
{\tt public boolean {\bf containsKey}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsValue}
\item{\vskip -1.9ex 
\membername{containsValue}
{\tt public boolean {\bf containsValue}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{entrySet}
\item{\vskip -1.9ex 
\membername{entrySet}
{\tt public abstract Set {\bf entrySet}(  )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Object {\bf get}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{keySet}
\item{\vskip -1.9ex 
\membername{keySet}
{\tt public Set {\bf keySet}(  )
}%end signature
}%end item
\divideents{put}
\item{\vskip -1.9ex 
\membername{put}
{\tt public Object {\bf put}( {\tt java.lang.Object } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{putAll}
\item{\vskip -1.9ex 
\membername{putAll}
{\tt public void {\bf putAll}( {\tt java.util.Map } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public Collection {\bf values}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
}
}
\newpage
\def\packagename{net.parallaxed.bluejam}
\chapter{\bf Package net.parallaxed.bluejam}{
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Interfaces}
\entityintro{Function}{l55}{This interface defines the behaviours of a GP function.}
\entityintro{Heuristic}{l56}{A heuristic is any class that can provide a pattern template
 upon which a terminal set can evolve.}
\entityintro{NoteSequence}{l57}{NoteSequence is the interface describing operations that can be
 performed over a sequence of Notes.}
\entityintro{Terminal}{l58}{All terminals must have unique identifiers to satisfy
 uniqueness in a TerminalSet.}
\vskip .13in
\hbox{\bf Classes}
\entityintro{Accidental}{l59}{Defines the possible accidentals.}
\entityintro{Evolve}{l60}{The evolve class carries out the main evolution cycles and
 outputs "winning" musical candidates by notifying listeners.}
\entityintro{EvolveHeuristic}{l61}{TODO Implement this.}
\entityintro{HeuristicCollection}{l62}{Provides a class to store population heuristics and select them
 using different modes$/$distributions.}
\entityintro{HeuristicCollection.SELECTION\_TYPE}{l63}{This Enum provides defines the possible methods by which 
 heuristics are selected from the collection}
\entityintro{Individual}{l64}{This class defines an individual.}
\entityintro{IndividualParameters}{l65}{If the individual desires different parameters from those
 defined in the population by default, it can override the
 population's decision by creating a class of 
 IndividualParameters.}
\entityintro{JamParamters}{l66}{The ParameterCollection class is used by BlueJam to specify 
 the properties of a cycle of evolution.}
\entityintro{JamParamters.Config}{l67}{Defines the typed configuration values in a ParameterCollection}
\entityintro{Mutable}{l68}{Utility Class defining which properties of a note can be changed.}
\entityintro{Note}{l20}{This class is currently under consideration for the "abstract"
 modifier.}
\entityintro{NoteCollection}{l69}{Simply contains a list of notes in their order of play.}
\entityintro{NoteLeaf}{l70}{Implements a unary note-sequence (only one note in the 
 sequence)
 
 NoteLeaf instances extend the functionality of Note, such that
 it can be added and manipulated within a NoteTree.}
\entityintro{NoteLeafSet}{l71}{The note set of all possible pitch classes in the octave
 range supplied to the constructor.}
\entityintro{NoteTree}{l72}{Note trees are a data structure representing an unordered 
 tree of NoteSequences, itself forming a note sequence.}
\entityintro{Pitch}{l73}{This enumeration represents the pitches and can be used to
 determine enharmonic equivalence between pitch classes.}
\entityintro{Population}{l74}{The population class holds a collection of individuals and
 evolves them with or without a set of heuristics.}
\entityintro{PopulationParameters}{l75}{Provides a moderately strongly typed parameter collection
 for the population properties and constants.}
\entityintro{Rhythm}{l76}{This Enum contains all the rhythm's BlueJam supports.}
\entityintro{Scale}{l77}{This Enum describes how to produce each scale using stepped 
 jumps over pitch classes.}
\entityintro{Scale.BLUES}{l78}{Defines a blues scale with hexatonic pitch representation.}
\entityintro{Scale.MAJOR}{l79}{Defines a standard major scale.}
\entityintro{Scale.MINOR}{l80}{Defines a standard minor scale.}
\entityintro{ScaledSet}{l81}{Given a set of rules for the scale, ScaledSet can work out 
 the set of notes that fit that scale, over a given number
 of octaves.}
\entityintro{SequenceParameters}{l82}{Currently, custom tree parameters aren't supported, so this
 default instantiation should cover the basics.}
\entityintro{TerminalSet}{l83}{Wraps an ArrayList to provide set-like functionality 
 (one unique instance per set).}
\entityintro{TreeParser}{l84}{This class reads in information from passed tree files,
 which normally represent a serialized layout of a NoteSequence.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
\newpage
\section{Interfaces}{
\startsection{Interface}{Function}{l55}{%
{\small This interface defines the behaviours of a GP function. 
 
 Since this interface is only to facilitate a gateway to the
 NoteSequence provided by any implementing classes, there is
 only one function - getNoteSequence().
 
 There may be multiple types of function (such as reverse,
 augment, swing etc), but the default implementation found
 here in the current classes is a vanilla "play()".}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
Function}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getNoteSequence}
{\tt public NoteSequence {\bf getNoteSequence}(  )
\label{l85}\label{l86}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Since the default function is to "play" the contents of 
 the tree, this function should return a reference to
 a playable note sequence.
 
 Provides a reference to the note sequence contained in
 the implementing class.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A reference to the NoteSequence 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{Heuristic}{l56}{%
{\small A heuristic is any class that can provide a pattern template
 upon which a terminal set can evolve.
 
 In BlueJam, the default implementation is the HeuristicTree.
 
 The heuristic tree is}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
Heuristic}}
\noindent\hbox{\vbox{{\bf implements} 
Function, NoteSequence}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{setSequenceParameters}
{\tt public void {\bf setSequenceParameters}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters} )
\label{l87}\label{l88}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Since NoteSequences should by default have some reference to
 sequenceParamaters, and the Genome (i.e. NoteTree) by default accepts this
 only in the constructor, we should have some method for
 overriding the sequenceParameters after construction on the 
 heuristic.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
\label{l89}\label{l90}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This defines a name for the heuristic, such
 that a particular instance can be pulled from a
 HeuristicCollection by name.
 
 Note this does not have to be unique globally, only
 within the collection if you wish to address the 
 heuristic individually.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The name of this heuristic. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{NoteSequence}{l57}{%
{\small NoteSequence is the interface describing operations that can be
 performed over a sequence of Notes.
 
 This class fully abstracts it's implementing classes to 
 potentially support alternatives to tree-based GP$/$EA approaches.
 
 The default implementation of NoteSequence is NoteTree$/$NoteLeaf,
 each having additional operations supporting a subset of GP
 operations.
 
 NoteSequence provides the basic functionality for 1-point crossover 
 and mutation, with replaceNotes().}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
NoteSequence}}
\noindent\hbox{\vbox{{\bf implements} 
java.lang.Cloneable}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{addNotes}
{\tt public boolean {\bf addNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l91}\label{l92}}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public NoteSequence {\bf clone}(  )
\label{l93}\label{l94}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
If supported, this should return a copy of this 
 NoteSequence independent from the original. This should
 be used mainly when an implementation wants to produce
 children or copies of itself.
 
 Heuristics use this method to return copies of
 themselves which can then be mutated.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A copy of this NoteSeqeunce 
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.CloneNotSupportedException} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l95}\label{l96}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The NoteSequence to look for}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True if this NoteSequence contains n 
}%end item
\end{itemize}
}%end item
\divideents{getNotes}
\item{\vskip -1.9ex 
\membername{getNotes}
{\tt public Iterator {\bf getNotes}(  )
\label{l97}\label{l98}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This abstracted function returns an iterator capable of
 accessing each note in the NoteSequence in an ordered
 fashion. Since an the representation of a note tree
 may be in no particular order, implementation of this
 function forces an order to be imposed at some point.
 
 In short, this allows the NoteSequence to be read into
 a buffer for playback through one of the appropriate classes
 
 NoteSequences are normally collapsed into NoteCollections
 using this iterator, to fix the ordering before playback.
 
 \_\_ADD SEE CLAUSES\_\_
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An iterator over all the notes in the NoteSequence 
}%end item
\end{itemize}
}%end item
\divideents{removeNotes}
\item{\vskip -1.9ex 
\membername{removeNotes}
{\tt public void {\bf removeNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l99}\label{l100}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Removes a note from the NoteSequence.
 
 Removal of a note should (in a linear representation) shift
 all subsequent notes left. For removing a note without this
 behaviour, see restNote()
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - A reference to the note to be removed.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sequenceParameters}
\item{\vskip -1.9ex 
\membername{sequenceParameters}
{\tt public SequenceParameters {\bf sequenceParameters}(  )
\label{l101}\label{l102}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns the parameters of this sequence. Normally only
 valid in function implementations, Terminals are not
 required to provide a link to their parameters.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A reference to the sequence parameters for this NoteSequence. 
}%end item
\end{itemize}
}%end item
\divideents{swapNotes}
\item{\vskip -1.9ex 
\membername{swapNotes}
{\tt public boolean {\bf swapNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf swapOut},
{\tt net.parallaxed.bluejam.NoteSequence } {\bf swapIn} )
\label{l103}\label{l104}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Swaps notes in a sequence. The supplied NoteSequence is
 located, and replaced by the given NoteSequence.
 
 Depending on the implementation, this function can be
 designed to act as mutation, 1-point crossover, or both.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt swapOut} - First argument to swap}
   \item{
\sld
{\tt swapIn} - Second argument to swap}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{validateNotes}
\item{\vskip -1.9ex 
\membername{validateNotes}
{\tt public void {\bf validateNotes}(  )
\label{l105}\label{l106}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Called before locking the note to make sure all
 properties covered by the lockMask are set.
 
 i.e. if lockMask = MUTABLE\_RHYTHM, all the rhythm
 related properties will be checked before setting
 this.mutable.
 	
 This method ensures all notes in the sequence are 
 ready for playback. Must be called before any attempt to
 read the noteValue or duration fields.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{Terminal}{l58}{%
{\small All terminals must have unique identifiers to satisfy
 uniqueness in a TerminalSet.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
Terminal}}
\noindent\hbox{\vbox{{\bf implements} 
java.lang.Cloneable}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getValue}
{\tt public int {\bf getValue}(  )
\label{l107}\label{l108}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns this terminal's value.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A unique identifier assigned by the implementing object. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
}
\section{Classes}{
\startsection{Class}{Accidental}{l59}{%
{\small Defines the possible accidentals.
 
 KEY is a special accidental remarking that the accidental
 should be the same as that of the root pitch.
 
 This class can be used to mark accidentals in relation to
 scale, but also in relation to a particular note. In null 
 cases, the null accidental (NONE) is returned.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
Accidental}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final Accidental SHARP\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Accidental FLAT\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Accidental NATURAL\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Accidental KEY\begin{itemize}\item{\vskip -.9ex The KEY accidental implies that if the note
 occurs inside a pitch class, the accidental
 should be the same as the accidental of the
 root pitch in that scale.}\end{itemize}
}
\item{
public static final Accidental NONE\begin{itemize}\item{\vskip -.9ex The NONE accidental is returned when the note
 is not inside a pitch class (on it's own). When used to 
 evaluate the presence of an accidental in a scale, 
 it behaves in a similar way to KEY, but in the case
 of a natural present on the note, NONE should always
 bias itself to remove the accidental on that NOTE.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Accidental {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l109}\label{l110}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final Accidental {\bf values}(  )
\label{l111}\label{l112}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Evolve}{l60}{%
{\small The evolve class carries out the main evolution cycles and
 outputs "winning" musical candidates by notifying listeners. Instances
 of this object are meant to be run in their own thread.
 
 As the generations are run, registered listeners will receive
 references to NoteSequences. Feedback can be given on these
 sequences by calling the feedback() method with a score
 and a reference back to the NoteSequence that achieved that score.
 In the case of positive feedback, the system can choose to
 make that candidate and other high-scoring candidates from the
 population "elite", which means they get passed in to 
 subsequent generations.
 
 This class implements the Player interface, a primitive events
 pattern.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
Evolve}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
java.lang.Runnable, net.parallaxed.bluejam.playback.Player}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public boolean running\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Evolve}
{\tt public {\bf Evolve}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters},
{\tt int } {\bf populationCount} )
\label{l114}\label{l115}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Creates an instance of the Evolve class
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt sequenceParameters} - The sequenceParameters to use.}
  \end{itemize}
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.SequenceParameters} {\small 
\refdefined{l82}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Evolve}
\item{\vskip -1.9ex 
\membername{Evolve}
{\tt public {\bf Evolve}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters},
{\tt int } {\bf populationCount},
{\tt net.parallaxed.bluejam.HeuristicCollection } {\bf heuristics} )
\label{l116}\label{l117}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Creates an instance of the Evolve class.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt sequenceParameters} - The sequenceParameters to use.}
   \item{
\sld
{\tt heuristics} - The HeuristicCollection to use.}
  \end{itemize}
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.SequenceParameters} {\small 
\refdefined{l82}}%end \small
}%end item
   \item{{\tt net.parallaxed.bluejam.HeuristicCollection} {\small 
\refdefined{l62}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{addListener}
{\tt public void {\bf addListener}( {\tt net.parallaxed.bluejam.playback.Listener } {\bf listener} )
\label{l118}\label{l119}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Adds a listener to this player.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{feedback}
\item{\vskip -1.9ex 
\membername{feedback}
{\tt public void {\bf feedback}( {\tt int } {\bf feedback},
{\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l120}\label{l121}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Accepts a positive or negative feedback value (usually
 -1 or 0 or 1), and turns on elitism for that NoteSequence
 making it appear in subsequent generations.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{generations}
\item{\vskip -1.9ex 
\membername{generations}
{\tt public int {\bf generations}(  )
\label{l122}\label{l123}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
The number of generations we're going to run.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{generations}
\item{\vskip -1.9ex 
\membername{generations}
{\tt public void {\bf generations}( {\tt int } {\bf numberOfGenerations} )
\label{l124}\label{l125}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the number of generations. Limit: 0 \textless  x \textless  100
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt numberOfGenerations} - The number of generations to complete}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getPopulationParameters}
\item{\vskip -1.9ex 
\membername{getPopulationParameters}
{\tt public PopulationParameters {\bf getPopulationParameters}(  )
\label{l126}\label{l127}}%end signature
}%end item
\divideents{matingPoolSize}
\item{\vskip -1.9ex 
\membername{matingPoolSize}
{\tt public void {\bf matingPoolSize}( {\tt int } {\bf matingPoolSize} )
\label{l128}\label{l129}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the size of the mating pool. Limit: 1 \textless  x \textless  21
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt matingPoolSize} - The new size of the pool}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{run}
\item{\vskip -1.9ex 
\membername{run}
{\tt public void {\bf run}(  )
\label{l130}\label{l131}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Runs the main evolution thread.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{setPopulationCount}
\item{\vskip -1.9ex 
\membername{setPopulationCount}
{\tt public void {\bf setPopulationCount}( {\tt int } {\bf memberCount} )
\label{l132}\label{l133}}%end signature
}%end item
\divideents{togglePause}
\item{\vskip -1.9ex 
\membername{togglePause}
{\tt public void {\bf togglePause}(  )
\label{l134}\label{l135}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Pauses the evolution from outside this thread.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{EvolveHeuristic}{l61}{%
{\small TODO Implement this.
 
 This class should deal with outputting the evolved heuristics
 into a serial format.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
EvolveHeuristic}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{EvolveHeuristic}
{\tt public {\bf EvolveHeuristic}(  )
\label{l136}\label{l137}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{HeuristicCollection}{l62}{%
{\small Provides a class to store population heuristics and select them
 using different modes$/$distributions. 
 
 Calling selectHeuristic() returns a heuristic from the collection.
 
 This class uses the ECJ implementation of MersenneTwisterFast.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
HeuristicCollection}}
\noindent\hbox{\vbox{{\bf extends} java.util.ArrayList}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private int \_index\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
private MersenneTwisterFast \_mt\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public HeuristicCollection.SELECTION\_TYPE MODE\begin{itemize}\item{\vskip -.9ex Specifies which selection type to use in this collection.}\end{itemize}
}
\item{
private HashMap \_byName\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public HeuristicCollection.SELECTION\_TYPE MODE\begin{itemize}\item{\vskip -.9ex Specifies which selection type to use in this collection.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{HeuristicCollection}
{\tt public {\bf HeuristicCollection}(  )
\label{l138}\label{l139}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Initialises a HeuristicCollection (trivial)
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Heuristic } {\bf heuristic} )
\label{l140}\label{l141}}%end signature
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Heuristic } {\bf heuristic},
{\tt java.lang.String } {\bf name} )
\label{l142}\label{l143}}%end signature
}%end item
\divideents{getHeuristic}
\item{\vskip -1.9ex 
\membername{getHeuristic}
{\tt public Heuristic {\bf getHeuristic}( {\tt java.lang.String } {\bf name} )
\label{l144}\label{l145}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a heuristic by name if it is present in the collection.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} - The name of the desired heuristic}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A reference to the named heuristic, or null. 
}%end item
\end{itemize}
}%end item
\divideents{loadHeuristics}
\item{\vskip -1.9ex 
\membername{loadHeuristics}
{\tt public static HeuristicCollection {\bf loadHeuristics}( {\tt java.lang.String } {\bf path} )
\label{l146}\label{l147}}%end signature
}%end item
\divideents{selectHeuristic}
\item{\vskip -1.9ex 
\membername{selectHeuristic}
{\tt public Heuristic {\bf selectHeuristic}(  )
\label{l148}\label{l149}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a heuristic in line with the method selected
 by MODE.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A heuristic from the collection 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.HeuristicCollection.SELECTION\_TYPE} {\small 
\refdefined{l63}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.util.ArrayList}}{
\par{\small 
\refdefined{l150}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public void {\bf add}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt int } {\bf arg0},
{\tt java.util.Collection } {\bf arg1} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public Object {\bf clone}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{ensureCapacity}
\item{\vskip -1.9ex 
\membername{ensureCapacity}
{\tt public void {\bf ensureCapacity}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Object {\bf get}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{indexOf}
\item{\vskip -1.9ex 
\membername{indexOf}
{\tt public int {\bf indexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{lastIndexOf}
\item{\vskip -1.9ex 
\membername{lastIndexOf}
{\tt public int {\bf lastIndexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeRange}
\item{\vskip -1.9ex 
\membername{removeRange}
{\tt protected void {\bf removeRange}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\membername{set}
{\tt public Object {\bf set}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{trimToSize}
\item{\vskip -1.9ex 
\membername{trimToSize}
{\tt public void {\bf trimToSize}(  )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractList}}{
\par{\small 
\refdefined{l151}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public void {\bf add}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt int } {\bf arg0},
{\tt java.util.Collection } {\bf arg1} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public abstract Object {\bf get}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{indexOf}
\item{\vskip -1.9ex 
\membername{indexOf}
{\tt public int {\bf indexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{lastIndexOf}
\item{\vskip -1.9ex 
\membername{lastIndexOf}
{\tt public int {\bf lastIndexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{listIterator}
\item{\vskip -1.9ex 
\membername{listIterator}
{\tt public ListIterator {\bf listIterator}(  )
}%end signature
}%end item
\divideents{listIterator}
\item{\vskip -1.9ex 
\membername{listIterator}
{\tt public ListIterator {\bf listIterator}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{removeRange}
\item{\vskip -1.9ex 
\membername{removeRange}
{\tt protected void {\bf removeRange}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\membername{set}
{\tt public Object {\bf set}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{subList}
\item{\vskip -1.9ex 
\membername{subList}
{\tt public List {\bf subList}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractCollection}}{
\par{\small 
\refdefined{l152}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsAll}
\item{\vskip -1.9ex 
\membername{containsAll}
{\tt public boolean {\bf containsAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public abstract Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{retainAll}
\item{\vskip -1.9ex 
\membername{retainAll}
{\tt public boolean {\bf retainAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public abstract int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{HeuristicCollection.SELECTION\_TYPE}{l63}{%
{\small This Enum provides defines the possible methods by which 
 heuristics are selected from the collection}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static final 
class 
HeuristicCollection.SELECTION\_TYPE}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final HeuristicCollection.SELECTION\_TYPE EVEN\begin{itemize}\item{\vskip -.9ex An even distribution will iterate over the contents of the
 collection, then return to normal, so each heuristic
 is selected evenly.}\end{itemize}
}
\item{
public static final HeuristicCollection.SELECTION\_TYPE RANDOM\begin{itemize}\item{\vskip -.9ex A random selection uses an instance of MersenneTwisterFast to 
 pick out a heuristic.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static HeuristicCollection.SELECTION\_TYPE {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l153}\label{l154}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final HeuristicCollection.SELECTION\_TYPE {\bf values}(  )
\label{l155}\label{l156}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Individual}{l64}{%
{\small This class defines an individual. Also could be termed a
 chromosome in GP, but our individuals represent instances of 
 NoteTrees based around a given Heuristic present in the
 population.
 
 An individual implements Function in the sense that it has
 access to the "play()" function in the NoteSequence
 represented by the individual. Theoretically, this permits
 individuals and their sequences to be chained together.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
Individual}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
Function}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Individual}
{\tt public {\bf Individual}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.Heuristic } {\bf heuristic} )
\label{l157}\label{l158}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For creating an individual outside a population in crossover
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The NoteSequence to initialize the Individual with}
   \item{
\sld
{\tt heuristic} - The heuristic used to build this individual.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Individual}
\item{\vskip -1.9ex 
\membername{Individual}
{\tt public {\bf Individual}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf popParams} )
\label{l159}\label{l160}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For creating an individual outside a population (mostly
 for testing)
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The NoteSequence to initialize the Individual with}
   \item{
\sld
{\tt popParams} - The parameters the individual should take.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Individual}
\item{\vskip -1.9ex 
\membername{Individual}
{\tt public {\bf Individual}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf popParams},
{\tt net.parallaxed.bluejam.Heuristic } {\bf heuristic} )
\label{l161}\label{l162}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For creating an individual outside a population (mostly
 for testing) with a heuristic.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The NoteSequence to initialize the Individual with}
   \item{
\sld
{\tt popParams} - The parameters the individual should take.}
   \item{
\sld
{\tt heuristic} - The heuristic to use for initialize()}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Individual}
\item{\vskip -1.9ex 
\membername{Individual}
{\tt public {\bf Individual}( {\tt net.parallaxed.bluejam.Population } {\bf population} )
\label{l163}\label{l164}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Creates an individual with no given heuristic.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt population} - The population that this individual belongs to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Individual}
\item{\vskip -1.9ex 
\membername{Individual}
{\tt public {\bf Individual}( {\tt net.parallaxed.bluejam.Population } {\bf population},
{\tt net.parallaxed.bluejam.Heuristic } {\bf heuristic} )
\label{l165}\label{l166}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Creates this individual with a given Heuristic.
 
 The heuristic passed will be used to create the base 
 note sequence for this individual.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt population} - The population that this individual belongs to.}
   \item{
\sld
{\tt heuristic} - A heuristic for evolving this individual's NoteSequence.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Individual}
\item{\vskip -1.9ex 
\membername{Individual}
{\tt public {\bf Individual}( {\tt net.parallaxed.bluejam.PopulationParameters } {\bf popParams},
{\tt net.parallaxed.bluejam.Heuristic } {\bf heuristic} )
\label{l167}\label{l168}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For creating an individual outside a population (mostly
 for testing) with a heuristic.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt popParams} - The parameters the individual should take.}
   \item{
\sld
{\tt heuristic} - The heuristic to use for initialize()}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{evaluate}
{\tt public double {\bf evaluate}(  )
\label{l169}\label{l170}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Gives the fitness of this individual or throws an exception
 if the individual is not evaluated yet.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The fitness of the individual 
}%end item
\end{itemize}
}%end item
\divideents{getHeuristic}
\item{\vskip -1.9ex 
\membername{getHeuristic}
{\tt public Heuristic {\bf getHeuristic}(  )
\label{l171}\label{l172}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a reference to the Heuristic used to create
 the individual, or null if no Heuristic was used.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
This individual's Heuristic, or null. 
}%end item
\end{itemize}
}%end item
\divideents{getNoteSequence}
\item{\vskip -1.9ex 
\membername{getNoteSequence}
{\tt public NoteSequence {\bf getNoteSequence}(  )
\label{l173}\label{l174}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getParameters}
\item{\vskip -1.9ex 
\membername{getParameters}
{\tt public PopulationParameters {\bf getParameters}(  )
\label{l175}\label{l176}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
This population's parameter object. 
}%end item
\end{itemize}
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}(  )
\label{l177}\label{l178}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Initialises the individual by parsing the heuristic into a 
 note tree. For optimisation reasons this might not always
 occur at instantiation.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{invalidate}
\item{\vskip -1.9ex 
\membername{invalidate}
{\tt public void {\bf invalidate}(  )
\label{l179}\label{l180}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the internal state of this individual such that the next
 call to evaluate() will re-evaluate the fitness of the
 Individual.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{population}
\item{\vskip -1.9ex 
\membername{population}
{\tt public void {\bf population}( {\tt net.parallaxed.bluejam.Population } {\bf population} )
\label{l181}\label{l182}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Reassigns this individual's population membership.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt population} - The population to place this individual in.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setParameter}
\item{\vskip -1.9ex 
\membername{setParameter}
{\tt public void {\bf setParameter}( {\tt java.lang.String } {\bf name},
{\tt java.lang.Object } {\bf value} )
\label{l183}\label{l184}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Will create and IndividualParameters instance for this object
 if it doesn't already have one, and set the given 
 individual parameter.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} - The parameter name.}
   \item{
\sld
{\tt value} - The parameter value.}
  \end{itemize}
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.IndividualParameters} {\small 
\refdefined{l65}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{IndividualParameters}{l65}{%
{\small If the individual desires different parameters from those
 defined in the population by default, it can override the
 population's decision by creating a class of 
 IndividualParameters.
 
 This only works for some parameters.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
IndividualParameters}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.PopulationParameters}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{IndividualParameters}
{\tt public {\bf IndividualParameters}( {\tt net.parallaxed.bluejam.PopulationParameters } {\bf params} )
\label{l185}\label{l186}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
If and individual can't resolve a parameter, it will 
 retrieve it from the parent.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt params} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{\_checkType}
{\tt protected boolean {\bf \_checkType}( {\tt java.lang.String } {\bf name},
{\tt java.lang.Object } {\bf value} )
\label{l187}\label{l188}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Ensures that only parameters specific to individuals can
 be overridden.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getParameter}
\item{\vskip -1.9ex 
\membername{getParameter}
{\tt public Object {\bf getParameter}( {\tt java.lang.String } {\bf name} )
\label{l189}\label{l190}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
If the value is not found in the individual parameters,
 will return them from the parent.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.PopulationParameters}}{
\par{\small 
\refdefined{l75}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{\_checkType}
{\tt protected boolean {\bf \_checkType}( {\tt java.lang.String } {\bf name},
{\tt java.lang.Object } {\bf value} )
}%end signature
}%end item
\divideents{getFitnessType}
\item{\vskip -1.9ex 
\membername{getFitnessType}
{\tt public FitnessType {\bf getFitnessType}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The FitnessType for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.FitnessType} {\small 
\refdefined{l191}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getGenotype}
\item{\vskip -1.9ex 
\membername{getGenotype}
{\tt public Genotype {\bf getGenotype}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The Genotype for this population 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.Genotype} {\small 
\refdefined{l192}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getInitializationType}
\item{\vskip -1.9ex 
\membername{getInitializationType}
{\tt public InitializationType {\bf getInitializationType}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The InitializationType for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.InitializationType} {\small 
\refdefined{l193}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getParameter}
\item{\vskip -1.9ex 
\membername{getParameter}
{\tt public Object {\bf getParameter}( {\tt java.lang.String } {\bf parameter} )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
An object of the value of that parameter, or null if not found. 
}%end item
\end{itemize}
}%end item
\divideents{getSelectionPressure}
\item{\vskip -1.9ex 
\membername{getSelectionPressure}
{\tt public Integer {\bf getSelectionPressure}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The SelectionPressure for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.SelectTournament} {\small 
\refdefined{l194}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getSelectionType}
\item{\vskip -1.9ex 
\membername{getSelectionType}
{\tt public SelectionType {\bf getSelectionType}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The SelectionType for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.SelectionType} {\small 
\refdefined{l195}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getSequenceParameters}
\item{\vskip -1.9ex 
\membername{getSequenceParameters}
{\tt public SequenceParameters {\bf getSequenceParameters}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
JamParameters can also be obtained through here.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The SequenceParameters instance used in this population. 
}%end item
\end{itemize}
}%end item
\divideents{setParameter}
\item{\vskip -1.9ex 
\membername{setParameter}
{\tt public void {\bf setParameter}( {\tt java.lang.String } {\bf name},
{\tt java.lang.Object } {\bf value} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets a parameter using moderately strict type checking.
 
 Value and name must both be non-null and supported by the
 Parameter collection type (either Individual or Population).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} - The name of the parameter to set}
   \item{
\sld
{\tt value} - The object value to set the parameter to.}
  \end{itemize}
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.ParameterException} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{JamParamters}{l66}{%
{\small The ParameterCollection class is used by BlueJam to specify 
 the properties of a cycle of evolution. 
 
 Each ParameterCollection is passed down to a population, which
 uses it to configure it's individuals. Parameter collections are
 immutable, since the individuals need access to read the
 values, but are prohibited from changing them.
 
 Separate configurations may evolve in different populations
 simultaneously to produce different solos.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
JamParamters}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{JamParamters}
{\tt public {\bf JamParamters}(  )
\label{l196}\label{l197}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Initialises a parameter collection with defaults.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{JamParamters}
\item{\vskip -1.9ex 
\membername{JamParamters}
{\tt public {\bf JamParamters}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitch},
{\tt net.parallaxed.bluejam.Scale } {\bf scale},
{\tt java.lang.Integer } {\bf tempo} )
\label{l198}\label{l199}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Initializes a Jam with the given parameterss
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitch} - The root pitch (one of the Pitch enum)}
   \item{
\sld
{\tt scale} - The scale to use (one of the Scale enum)}
   \item{
\sld
{\tt tempo} - An integer representing the beats per minute (BPM)}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getParameter}
{\tt public Object {\bf getParameter}( {\tt net.parallaxed.bluejam.JamParamters.Config } {\bf c} )
\label{l200}\label{l201}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method retrieves a typed parameter from the collection.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt c} - The configuration key to return}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
An untyped object that can be casted to an expected type 
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.Exception} - If the parameter does not exist in this ParameterCollection}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getParameter}
\item{\vskip -1.9ex 
\membername{getParameter}
{\tt public String {\bf getParameter}( {\tt java.lang.String } {\bf s} )
\label{l202}\label{l203}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Retrieves a parameter stored in stringParams, or throws
 an exception if the parameter is not found.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} - The parameter name to get}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The value of parameter s 
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.Exception} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getScaledSet}
\item{\vskip -1.9ex 
\membername{getScaledSet}
{\tt public ScaledSet {\bf getScaledSet}(  )
\label{l204}\label{l205}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Terminals for the current Jam can be pulled from this
 ScaledSet.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A reference to this JamParameters ScaledSet. 
}%end item
\end{itemize}
}%end item
\divideents{maxOctave}
\item{\vskip -1.9ex 
\membername{maxOctave}
{\tt public int {\bf maxOctave}(  )
\label{l206}\label{l207}}%end signature
}%end item
\divideents{minOctave}
\item{\vskip -1.9ex 
\membername{minOctave}
{\tt public int {\bf minOctave}(  )
\label{l208}\label{l209}}%end signature
}%end item
\divideents{readConfig}
\item{\vskip -1.9ex 
\membername{readConfig}
{\tt public void {\bf readConfig}( {\tt java.io.File } {\bf file} )
\label{l210}\label{l211}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Reads in the supplied file and configures the ParameterCollection
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt file} - A java.io.File object to read.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{readConfig}
\item{\vskip -1.9ex 
\membername{readConfig}
{\tt public void {\bf readConfig}( {\tt java.lang.String } {\bf path} )
\label{l212}\label{l213}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Reads in a config file at the specified (absolute) path.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt path} - The path to the config file.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{rootPitch}
\item{\vskip -1.9ex 
\membername{rootPitch}
{\tt public Pitch {\bf rootPitch}(  )
\label{l214}\label{l215}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns the root pitch of this configuration as a type
 Pitch.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The root Pitch. 
}%end item
\end{itemize}
}%end item
\divideents{rootPitch}
\item{\vskip -1.9ex 
\membername{rootPitch}
{\tt public void {\bf rootPitch}( {\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch} )
\label{l216}\label{l217}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the root pitch of this Jam
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rootPitch} - The rootPitch of the Jam (cannot be Pitch.R)}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{scale}
\item{\vskip -1.9ex 
\membername{scale}
{\tt public Scale {\bf scale}(  )
\label{l218}\label{l219}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The scale being used in this Jam 
}%end item
\end{itemize}
}%end item
\divideents{scale}
\item{\vskip -1.9ex 
\membername{scale}
{\tt public void {\bf scale}( {\tt net.parallaxed.bluejam.Scale } {\bf scale} )
\label{l220}\label{l221}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the scale of this Jam
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt scale} - A reference to the singleton Scale instance.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setParameter}
\item{\vskip -1.9ex 
\membername{setParameter}
{\tt public void {\bf setParameter}( {\tt java.lang.String } {\bf s},
{\tt java.lang.String } {\bf value} )
\label{l222}\label{l223}}%end signature
}%end item
\divideents{setRange}
\item{\vskip -1.9ex 
\membername{setRange}
{\tt public void {\bf setRange}( {\tt int } {\bf minOctave},
{\tt int } {\bf maxOctave} )
\label{l224}\label{l225}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the range of the Jam, in octaves.
 
 Both values must be -1 \textless  x \textless  10.
 
 Also, (minOctave \textless = maxOctave) must be true, otherwise
 no action will be taken.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{tempo}
\item{\vskip -1.9ex 
\membername{tempo}
{\tt public void {\bf tempo}( {\tt int } {\bf tempo} )
\label{l226}\label{l227}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the tempo of this Jam
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt tempo} - A BPM value between 1-240}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{JamParamters.Config}{l67}{%
{\small Defines the typed configuration values in a ParameterCollection}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static final 
class 
JamParamters.Config}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final JamParamters.Config ROOT\_PITCH\begin{itemize}\item{\vskip -.9ex (Pitch) The root pitch around which to evolve.
 Default = A440}\end{itemize}
}
\item{
public static final JamParamters.Config TEMPO\begin{itemize}\item{\vskip -.9ex (Integer) The tempo (in beats per minute - BPM).
 Default = 120bpm}\end{itemize}
}
\item{
public static final JamParamters.Config SCALE\begin{itemize}\item{\vskip -.9ex (Scale) One of the supported "Scales" enumeration values.
 Default = Blues.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
\label{l228}\label{l229}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
The string value of each enum.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static JamParamters.Config {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l230}\label{l231}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final JamParamters.Config {\bf values}(  )
\label{l232}\label{l233}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Mutable}{l68}{%
{\small Utility Class defining which properties of a note can be changed.
 Assigns bitmasks to deal with permissions under NoteLeaf.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
Mutable}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final byte NONE\begin{itemize}\item{\vskip -.9ex Indicates none of the note properties can be changed.}\end{itemize}
}
\item{
public static final byte RHYTHM\begin{itemize}\item{\vskip -.9ex This note can have it's duration increased$/$decreased 
 (in the note tree implementation, this note can change
 it's level in the tree).}\end{itemize}
}
\item{
public static final byte PITCH\begin{itemize}\item{\vskip -.9ex The pitchClass$/$noteValue can change. The note can also
 toggleRest()}\end{itemize}
}
\item{
public static final byte ALL\begin{itemize}\item{\vskip -.9ex Both pitch and rhythm can change (sum of other flag
 values).}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Mutable}
{\tt public {\bf Mutable}(  )
\label{l234}\label{l235}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{Note}{l20}{%
{\small This class is currently under consideration for the "abstract"
 modifier.
 
 This class fully abstracts the properties of a note from 
 the possible implementations of notes in the evolution
 framework.
 
 Since BlueJam is entirely tree based, the default extension
 of this class is NoteLeaf. Notes can belong to more than one
 collection. A NoteLeaf can also belong to more that one
 collection, but only one NoteTree.
 
 Once stored in a structure, the only safe way to manipulate
 the note is through the methods defined on the type
 specific to that data structure -i.e. it's not recommended
 to typecast to Note in order to bypass things like locking
 protection.
 
 All subclasses of Note involved in a GP algorithm should
 also implement Terminal.
 
 TODO Event-driven pattern for Note validation to inform children.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
Note}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final long serialVersionUID\begin{itemize}\item{\vskip -.9ex This requires post-processing by an output class.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Note}
{\tt public {\bf Note}(  )
\label{l236}\label{l237}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Trivial Constructor for later application of properties.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{Note}
\item{\vskip -1.9ex 
\membername{Note}
{\tt public {\bf Note}( {\tt float } {\bf noteValue} )
\label{l238}\label{l239}}%end signature
}%end item
\divideents{Note}
\item{\vskip -1.9ex 
\membername{Note}
{\tt public {\bf Note}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitchClass},
{\tt int } {\bf octave} )
\label{l240}\label{l241}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a note with the given pitch class and octave
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - }
   \item{
\sld
{\tt octave} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{duration}
{\tt public double {\bf duration}(  )
\label{l242}\label{l243}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Retrieves the duration of the note.
 
 Logs an exception if the note was not validated
 prior to playback.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The length of this note in milliseconds. 
}%end item
\end{itemize}
}%end item
\divideents{duration}
\item{\vskip -1.9ex 
\membername{duration}
{\tt protected void {\bf duration}( {\tt double } {\bf milliseconds} )
\label{l244}\label{l245}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the duration of the note. This value is sent out
 along the MIDI line to tell the ouput device how long
 to hold the note for.
 
 Can only be called by it's subclasses that deal with
 how long the note should be played for.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt milliseconds} - The new duration in milliseconds.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{evaluatedPitch}
\item{\vskip -1.9ex 
\membername{evaluatedPitch}
{\tt public Pitch {\bf evaluatedPitch}(  )
\label{l246}\label{l247}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A value for the calculated pitch. 
}%end item
\end{itemize}
}%end item
\divideents{evaluatePitch}
\item{\vskip -1.9ex 
\membername{evaluatePitch}
{\tt protected boolean {\bf evaluatePitch}( {\tt net.parallaxed.bluejam.JamParamters } {\bf params} )
\label{l248}\label{l249}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Evaluates this Note in the given JamParameters context.
 
 JamParameters supplies the root pitch. The actual pitch of 
 this note is supplied by 0 \textless  pitchRelative \textless  11, which is 
 added as an offset to the root pitch to give the real pitch.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt params} - The JamParameters context - passed from somewhere on high.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True on success, false on failure. 
}%end item
\end{itemize}
}%end item
\divideents{evaluatePitch}
\item{\vskip -1.9ex 
\membername{evaluatePitch}
{\tt public boolean {\bf evaluatePitch}( {\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch} )
\label{l250}\label{l251}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
A note can be defined as "relative", in the context of 
 a given pitch and scale.
 
 If a note is relative, it will remain invalid until this
 method is called with some notion of context (i.e. a root
 pitch and a scale).
 
 This method will resolve the relative position of this note
 into an absolute pitch value.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rootPitch} - The root pitch to evaluate against}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{evaluateRhythm}
\item{\vskip -1.9ex 
\membername{evaluateRhythm}
{\tt public boolean {\bf evaluateRhythm}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf params} )
\label{l252}\label{l253}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Evaluates the rhythm of this note given the passed 
 SequenceParameters. These need to be passed in from 
 an implementation of Note.
 
 Error's will be sent to the default ErrorFeedback.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt params} - The given SequenceParameters ("context")}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
Whether the evaluation succeeded or not. 
}%end item
\end{itemize}
}%end item
\divideents{invalidate}
\item{\vskip -1.9ex 
\membername{invalidate}
{\tt protected void {\bf invalidate}(  )
\label{l254}\label{l255}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Marks this note as invalid.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{noteValue}
\item{\vskip -1.9ex 
\membername{noteValue}
{\tt public float {\bf noteValue}(  )
\label{l256}\label{l257}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
The MIDI note number of this note.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A float between 0 and 127 
}%end item
\end{itemize}
}%end item
\divideents{octave}
\item{\vskip -1.9ex 
\membername{octave}
{\tt public int {\bf octave}(  )
\label{l258}\label{l259}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns the octave number.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The octave the note is in 
}%end item
\end{itemize}
}%end item
\divideents{octave}
\item{\vskip -1.9ex 
\membername{octave}
{\tt public void {\bf octave}( {\tt int } {\bf octave} )
\label{l260}\label{l261}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the octave of this note if it can be 
 arbitrarily changed.
 
 Subclasses should override this to account for locks
 if necessary.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt octave} - The new octave number}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pitchClass}
\item{\vskip -1.9ex 
\membername{pitchClass}
{\tt public Pitch {\bf pitchClass}(  )
\label{l262}\label{l263}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The Pitch class of this note. 
}%end item
\end{itemize}
}%end item
\divideents{pitchClass}
\item{\vskip -1.9ex 
\membername{pitchClass}
{\tt public void {\bf pitchClass}( {\tt net.parallaxed.bluejam.Pitch } {\bf p} )
\label{l264}\label{l265}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Set the pitchClass of this note.
 
 Subclasses should override this fully to account for mutability
 of note properties.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} - The desired pitchClass}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pitchRelative}
\item{\vskip -1.9ex 
\membername{pitchRelative}
{\tt public int {\bf pitchRelative}(  )
\label{l266}\label{l267}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Used when pitch = Pitch.R to calculate the absolute pitch of the note.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The number of steps to this note from the root 
}%end item
\end{itemize}
}%end item
\divideents{pitchRelative}
\item{\vskip -1.9ex 
\membername{pitchRelative}
{\tt public void {\bf pitchRelative}( {\tt int } {\bf offset} )
\label{l268}\label{l269}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the pitch relative to the given root note + octave.
 
 Used when evaluating heuristic trees.
 
 If this number is negative, the root note is above the note
 If this number is positive, the root note is below the note
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt offset} - The number of steps (semitones) between the root note and this note.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{rest}
\item{\vskip -1.9ex 
\membername{rest}
{\tt public boolean {\bf rest}(  )
\label{l270}\label{l271}}%end signature
}%end item
\divideents{rhythm}
\item{\vskip -1.9ex 
\membername{rhythm}
{\tt public Rhythm {\bf rhythm}(  )
\label{l272}\label{l273}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Only accessed when initially adding this NoteLeaf to
 a NoteTree.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The rhythm of the note 
}%end item
\end{itemize}
}%end item
\divideents{rhythm}
\item{\vskip -1.9ex 
\membername{rhythm}
{\tt public void {\bf rhythm}( {\tt net.parallaxed.bluejam.Rhythm } {\bf r} )
\label{l274}\label{l275}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Only accessed when initially adding this NoteLeaf to
 a NoteTree.
 
 This method should be overridden (not just hidden) by classes
 that use locking.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{swingNote}
\item{\vskip -1.9ex 
\membername{swingNote}
{\tt public void {\bf swingNote}( {\tt int } {\bf swingPercent},
{\tt net.parallaxed.bluejam.Note } {\bf swingPartner} )
\label{l276}\label{l277}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Adds swing to a given note.
 
 A swing of 100\% is equivalent to a tied note.
 
 Swing is the act of pairing off two notes and then
 assigning a ratio to control their rhythmic value.
 
 This function will automatically assign the right 
 swing value to the partner note.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt swingPercent} - The amount of swing to assign to this note}
   \item{
\sld
{\tt swingPartner} - The swing partner of this note}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{swingPartner}
\item{\vskip -1.9ex 
\membername{swingPartner}
{\tt public Note {\bf swingPartner}(  )
\label{l278}\label{l279}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The note partnered with this one. 
}%end item
\end{itemize}
}%end item
\divideents{swingPercent}
\item{\vskip -1.9ex 
\membername{swingPercent}
{\tt public int {\bf swingPercent}(  )
\label{l280}\label{l281}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The percentage swing on this note (if any). 
}%end item
\end{itemize}
}%end item
\divideents{toggleRest}
\item{\vskip -1.9ex 
\membername{toggleRest}
{\tt public void {\bf toggleRest}(  )
\label{l282}\label{l283}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Toggles rest on$/$off.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{toggleRest}
\item{\vskip -1.9ex 
\membername{toggleRest}
{\tt public void {\bf toggleRest}( {\tt boolean } {\bf rest} )
\label{l284}\label{l285}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets this note to be a rest given the passed boolean.
 
 No information about the note is lost by turning it into
 a rest note. This can be undone at a later stage by calling
 toggleRest() again.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rest} - True turns this into a rest note, false reverts.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
\label{l286}\label{l287}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns true if this note is a rest
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{validateNotes}
\item{\vskip -1.9ex 
\membername{validateNotes}
{\tt public void {\bf validateNotes}(  )
\label{l288}\label{l289}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method validates the note and throws the 
 right kind of exception if anything is awry.
 
 For some reason this method uses lazy evaluation to
 optimize screen real-estate.
}%end item
  \end{itemize}
}
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.ValidationException} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{validatePitch}
\item{\vskip -1.9ex 
\membername{validatePitch}
{\tt protected boolean {\bf validatePitch}(  )
\label{l290}\label{l291}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Checks that the pitchClass field has a value and that
 the value is not relative.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
True if the criteria are met, false otherwise. 
}%end item
\end{itemize}
}%end item
\divideents{validateRhythm}
\item{\vskip -1.9ex 
\membername{validateRhythm}
{\tt protected boolean {\bf validateRhythm}(  )
\label{l292}\label{l293}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Checks the duration of this note (in milliseconds) is \textgreater  0.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
True if the criteria are met, false otherwise. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{NoteCollection}{l69}{%
{\small Simply contains a list of notes in their order of play.
 
 Note that this class is recursively typed, even though it
 wraps a collection of \textless Note\textgreater , those elements added to it 
 MUST also implement NoteSequence.
 
 This class acts as a buffer between the playback classes 
 and the evolution classes (i.e. note trees etc).}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
NoteCollection}}
\noindent\hbox{\vbox{{\bf extends} java.util.ArrayList}}
\noindent\hbox{\vbox{{\bf implements} 
NoteSequence}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private HashMap \_idMap\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
private SequenceParameters \_sp\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{NoteCollection}
{\tt public {\bf NoteCollection}(  )
\label{l294}\label{l295}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a vanilla NoteCollection
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{NoteCollection}
\item{\vskip -1.9ex 
\membername{NoteCollection}
{\tt public {\bf NoteCollection}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters} )
\label{l296}\label{l297}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a NoteCollection with the passed sequenceParameters
 
 This is useful for subclasses that require context in their
 Collection.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt sequenceParameters} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Note } {\bf n} )
\label{l298}\label{l299}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Will check if a passed note has an ID, if so
 it will also be added to an internal HashMap for
 later retrieval.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{addNotes}
\item{\vskip -1.9ex 
\membername{addNotes}
{\tt public boolean {\bf addNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l300}\label{l301}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Appends the passed NoteSeqeunce to the NoteCollection.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The notes to be appended.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
Always true for this implementation. 
}%end item
\end{itemize}
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public NoteCollection {\bf clone}(  )
\label{l302}\label{l303}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
NoteCollections are note cloneable (...yet)
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l304}\label{l305}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The NoteSequence to search for}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True if this collection contains the passed NoteSequence. 
}%end item
\end{itemize}
}%end item
\divideents{crop}
\item{\vskip -1.9ex 
\membername{crop}
{\tt public NoteCollection {\bf crop}( {\tt int } {\bf index} )
\label{l306}\label{l307}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Crops a noteCollection returning all elements from the
 specified index to the end of the collection.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The note index where the crop begins}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A cropped copy of this NoteCollection 
}%end item
\end{itemize}
}%end item
\divideents{crop}
\item{\vskip -1.9ex 
\membername{crop}
{\tt public NoteCollection {\bf crop}( {\tt int } {\bf index},
{\tt int } {\bf end} )
\label{l308}\label{l309}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Crops a noteCollection returning all elements from the
 specified index to the point specified.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The note index where the crop begins}
   \item{
\sld
{\tt end} - Where to stop the crop.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A cropped copy of this NoteCollection 
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Note {\bf get}( {\tt int } {\bf index} )
\label{l310}\label{l311}}%end signature
}%end item
\divideents{getIndex}
\item{\vskip -1.9ex 
\membername{getIndex}
{\tt public Note {\bf getIndex}( {\tt int } {\bf index} )
\label{l312}\label{l313}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
To preserve original functionality, this simply calls the superclass get()
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The index to retrieve.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The note at index. 
}%end item
\end{itemize}
}%end item
\divideents{getNotes}
\item{\vskip -1.9ex 
\membername{getNotes}
{\tt public Iterator {\bf getNotes}(  )
\label{l314}\label{l315}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An iterator over this NoteCollection 
}%end item
\end{itemize}
}%end item
\divideents{removeNotes}
\item{\vskip -1.9ex 
\membername{removeNotes}
{\tt public void {\bf removeNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l316}\label{l317}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.NoteSequence} {\small 
\refdefined{l57}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sequenceParameters}
\item{\vskip -1.9ex 
\membername{sequenceParameters}
{\tt public SequenceParameters {\bf sequenceParameters}(  )
\label{l318}\label{l319}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A reference to this NoteCollection's SequenceParameters. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.SequenceParameters} {\small 
\refdefined{l82}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{swapNotes}
\item{\vskip -1.9ex 
\membername{swapNotes}
{\tt public boolean {\bf swapNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf swapOut},
{\tt net.parallaxed.bluejam.NoteSequence } {\bf swapIn} )
\label{l320}\label{l321}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.NoteSequence} {\small 
\refdefined{l57}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{validateNotes}
\item{\vskip -1.9ex 
\membername{validateNotes}
{\tt public void {\bf validateNotes}(  )
\label{l322}\label{l323}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Attempts to call validateNotes() on all it's children.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.util.ArrayList}}{
\par{\small 
\refdefined{l150}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public void {\bf add}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt int } {\bf arg0},
{\tt java.util.Collection } {\bf arg1} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public Object {\bf clone}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{ensureCapacity}
\item{\vskip -1.9ex 
\membername{ensureCapacity}
{\tt public void {\bf ensureCapacity}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Object {\bf get}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{indexOf}
\item{\vskip -1.9ex 
\membername{indexOf}
{\tt public int {\bf indexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{lastIndexOf}
\item{\vskip -1.9ex 
\membername{lastIndexOf}
{\tt public int {\bf lastIndexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeRange}
\item{\vskip -1.9ex 
\membername{removeRange}
{\tt protected void {\bf removeRange}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\membername{set}
{\tt public Object {\bf set}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{trimToSize}
\item{\vskip -1.9ex 
\membername{trimToSize}
{\tt public void {\bf trimToSize}(  )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractList}}{
\par{\small 
\refdefined{l151}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public void {\bf add}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt int } {\bf arg0},
{\tt java.util.Collection } {\bf arg1} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public abstract Object {\bf get}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{indexOf}
\item{\vskip -1.9ex 
\membername{indexOf}
{\tt public int {\bf indexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{lastIndexOf}
\item{\vskip -1.9ex 
\membername{lastIndexOf}
{\tt public int {\bf lastIndexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{listIterator}
\item{\vskip -1.9ex 
\membername{listIterator}
{\tt public ListIterator {\bf listIterator}(  )
}%end signature
}%end item
\divideents{listIterator}
\item{\vskip -1.9ex 
\membername{listIterator}
{\tt public ListIterator {\bf listIterator}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{removeRange}
\item{\vskip -1.9ex 
\membername{removeRange}
{\tt protected void {\bf removeRange}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\membername{set}
{\tt public Object {\bf set}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{subList}
\item{\vskip -1.9ex 
\membername{subList}
{\tt public List {\bf subList}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractCollection}}{
\par{\small 
\refdefined{l152}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsAll}
\item{\vskip -1.9ex 
\membername{containsAll}
{\tt public boolean {\bf containsAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public abstract Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{retainAll}
\item{\vskip -1.9ex 
\membername{retainAll}
{\tt public boolean {\bf retainAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public abstract int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{NoteLeaf}{l70}{%
{\small Implements a unary note-sequence (only one note in the 
 sequence)
 
 NoteLeaf instances extend the functionality of Note, such that
 it can be added and manipulated within a NoteTree. It is part
 of the default BlueJam implementation.
 
 Instances of this class can be manipulated in the same way as
 a note sequences, to add more notes (branch off) or swap
 itself.
 
 This class also implements Terminal, inferring that it can be
 part of a terminal set, and that when added to a NoteTree, the
 leaf is only manipulable within the bounds given by it's lockMask.
 
 Note that a Terminal on a NoteTree can only be condensed by having
 it's parent swapped out, it cannot be removed, only cleared (or
 "rested").
 
 Consider NoteLeaf interning by using a HashMap over the heap.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
NoteLeaf}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.Note}}
\noindent\hbox{\vbox{{\bf implements} 
NoteSequence, java.lang.Cloneable, Terminal, net.parallaxed.bluejam.playback.Saveable}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public int id\begin{itemize}\item{\vskip -.9ex This public identifier is only used when building 
 note trees to describe notes that may be paired into 
 swing partners, or have trails between them.
 
 Can also be used in NoteCollections to identify notes.}\end{itemize}
}
\item{
public NoteTree \_parent\begin{itemize}\item{\vskip -.9ex This should be set by the add() methods in NoteTree.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{NoteLeaf}
{\tt public {\bf NoteLeaf}( {\tt float } {\bf noteValue},
{\tt int } {\bf duration} )
\label{l324}\label{l325}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Shouldn't be used in this implementation - this is for
 reconstructing playback melodies only.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt noteValue} - The floatValue (MIDI number) of this note.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{NoteLeaf}
\item{\vskip -1.9ex 
\membername{NoteLeaf}
{\tt public {\bf NoteLeaf}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitchClass} )
\label{l326}\label{l327}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For initialization - no parent or octave is needed yet (these
 are contextually added).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - The pitchClass of this note}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{NoteLeaf}
\item{\vskip -1.9ex 
\membername{NoteLeaf}
{\tt public {\bf NoteLeaf}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitchClass},
{\tt int } {\bf octave} )
\label{l328}\label{l329}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For construction in a set - no parent is needed.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - The pitchClass of this note}
   \item{
\sld
{\tt octave} - The octave in which this note occurs.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{NoteLeaf}
\item{\vskip -1.9ex 
\membername{NoteLeaf}
{\tt public {\bf NoteLeaf}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitchClass},
{\tt net.parallaxed.bluejam.Rhythm } {\bf rhythm},
{\tt int } {\bf octave} )
\label{l330}\label{l331}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For construction at runtime.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - The pitchClass of this note}
   \item{
\sld
{\tt rhythm} - The rhythm of this note}
   \item{
\sld
{\tt octave} - The octave in which this note occurs}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{NoteLeaf}
\item{\vskip -1.9ex 
\membername{NoteLeaf}
{\tt public {\bf NoteLeaf}( {\tt net.parallaxed.bluejam.Rhythm } {\bf rhythm} )
\label{l332}\label{l333}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a NoteLeaf initialized with blank values
 (for building trees from files).
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{addNotes}
{\tt public boolean {\bf addNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l334}\label{l335}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Transforms this NoteLeaf into a NoteTree.
 
 Supports only the addition of NoteLeafs, therefore
 NoteSequences of size 1 only.
 
 The note currently on this leaf will split and accept
 one note in the given NoteSequence as it's child, if the
 rhythm for that NoteSequence is valid at this depth.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
True on success, false on failure. 
}%end item
\end{itemize}
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public NoteLeaf {\bf clone}(  )
\label{l336}\label{l337}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
 NB The proper way to do this would involve a call to super.clone()
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l338}\label{l339}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getNote}
\item{\vskip -1.9ex 
\membername{getNote}
{\tt public Note {\bf getNote}(  )
\label{l340}\label{l341}}%end signature
}%end item
\divideents{getNotes}
\item{\vskip -1.9ex 
\membername{getNotes}
{\tt public Iterator {\bf getNotes}(  )
\label{l342}\label{l343}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns an iterator that simply wraps this note to
 keep in line with the Iterator pattern.
 
 Somewhat expensive, possibly a candidate for optimization.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getValue}
\item{\vskip -1.9ex 
\membername{getValue}
{\tt public int {\bf getValue}(  )
\label{l344}\label{l345}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a unique signed integer for this note
 (the MIDI note number), or -1 if this note is relative.
 
 This method is used for building TerminalSets
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{isRelative}
\item{\vskip -1.9ex 
\membername{isRelative}
{\tt public boolean {\bf isRelative}(  )
\label{l346}\label{l347}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
True if this NoteLeaf bears relative pitch. 
}%end item
\end{itemize}
}%end item
\divideents{lockAll}
\item{\vskip -1.9ex 
\membername{lockAll}
{\tt protected void {\bf lockAll}(  )
\label{l348}\label{l349}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Attempts to lock all note properties and make the 
 note immutable - if this fails, an exception thrown
 explaining which properties are invalid.
 
 This is arbitrary, no validation takes place here.
 
 Subclasses must override these methods to provide 
 correct validation.
}%end item
  \end{itemize}
}
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.ValidationException} - if the note cannot be locked}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{lockMask}
\item{\vskip -1.9ex 
\membername{lockMask}
{\tt public void {\bf lockMask}( {\tt int } {\bf lockMask} )
\label{l350}\label{l351}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Will perform the appropriate lock operations given the
 passed mask.
 
 If the operation cannot be performed due to validation
 inconsistencies, this method will swallow the exception
 and forward it to an active display.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lockMask} - A non-negative integer}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{lockMask}
\item{\vskip -1.9ex 
\membername{lockMask}
{\tt public void {\bf lockMask}( {\tt int } {\bf lockMask},
{\tt boolean } {\bf force} )
\label{l352}\label{l353}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
TreeParser needs to be able to force a lock mash when 
 building trees from files.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lockMask} - A non-negative integer}
   \item{
\sld
{\tt force} - Whether to force the lock mask application or not}
  \end{itemize}
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.ValidationException} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{lockPitch}
\item{\vskip -1.9ex 
\membername{lockPitch}
{\tt protected void {\bf lockPitch}(  )
\label{l354}\label{l355}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This is arbitrary, no validation takes place here.
 
 Subclasses must override these methods to provide 
 correct validation.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{lockRhythm}
\item{\vskip -1.9ex 
\membername{lockRhythm}
{\tt protected void {\bf lockRhythm}(  )
\label{l356}\label{l357}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This is arbitrary, no validation takes place here.
 
 Subclasses must override these methods to provide 
 correct validation.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{mutable}
\item{\vskip -1.9ex 
\membername{mutable}
{\tt public byte {\bf mutable}(  )
\label{l358}\label{l359}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a bitmask indicating which parts of the note
 are mutable.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
a masked value from (0-3) 
}%end item
\end{itemize}
}%end item
\divideents{octave}
\item{\vskip -1.9ex 
\membername{octave}
{\tt public void {\bf octave}( {\tt int } {\bf octave} )
\label{l360}\label{l361}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.Note} {\small 
\refdefined{l20}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pitchClass}
\item{\vskip -1.9ex 
\membername{pitchClass}
{\tt public void {\bf pitchClass}( {\tt net.parallaxed.bluejam.Pitch } {\bf p} )
\label{l362}\label{l363}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.Note} {\small 
\refdefined{l20}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{removeNotes}
\item{\vskip -1.9ex 
\membername{removeNotes}
{\tt public void {\bf removeNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l364}\label{l365}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method simply sets the parent to null,
 if the passed NoteSequence == this.
 
 NB: the parent should erase this child (leaving a null
 gap in the children array). The function call passed to
 this node should simply be a signal to get ready and GC 
 the note.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The NoteSequence to remove}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{rhythm}
\item{\vskip -1.9ex 
\membername{rhythm}
{\tt public void {\bf rhythm}( {\tt net.parallaxed.bluejam.Rhythm } {\bf r} )
\label{l366}\label{l367}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
To honour locking.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{sequenceParameters}
\item{\vskip -1.9ex 
\membername{sequenceParameters}
{\tt public SequenceParameters {\bf sequenceParameters}(  )
\label{l368}\label{l369}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{stringify}
\item{\vskip -1.9ex 
\membername{stringify}
{\tt public String {\bf stringify}(  )
\label{l370}\label{l371}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a stringified version of this NoteLeaf
 $\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{swapNotes}
\item{\vskip -1.9ex 
\membername{swapNotes}
{\tt public boolean {\bf swapNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf swapOut},
{\tt net.parallaxed.bluejam.NoteSequence } {\bf swapIn} )
\label{l372}\label{l373}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
NoteLeaves do not support swapping - this should be
 done by NoteTree's (i.e. the \_parent)
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.NoteTree} {\small 
\refdefined{l72}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{swingNote}
\item{\vskip -1.9ex 
\membername{swingNote}
{\tt public void {\bf swingNote}( {\tt int } {\bf swingPercent},
{\tt int } {\bf swingPartnerId} )
\label{l374}\label{l375}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Used when building trees to assign a swing partner to 
 this NoteLeaf at a later time.
 
 swingPartnerId will be used to assign this.swingPartner
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt swingPercent} - The amount to swing this note}
   \item{
\sld
{\tt swingPartnerId} - The ID of the paired note}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{swingPartnerId}
\item{\vskip -1.9ex 
\membername{swingPartnerId}
{\tt public int {\bf swingPartnerId}(  )
\label{l376}\label{l377}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The ID of the swingPartner if this note leaf has one 
}%end item
\end{itemize}
}%end item
\divideents{validateNotes}
\item{\vskip -1.9ex 
\membername{validateNotes}
{\tt public void {\bf validateNotes}(  )
\label{l378}\label{l379}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Validates this NoteSequence.
 $\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{validatePitch}
\item{\vskip -1.9ex 
\membername{validatePitch}
{\tt protected boolean {\bf validatePitch}(  )
\label{l380}\label{l381}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Validates that this NoteLeaf is ready to play inside
 it's current context (assuming it has a parent), or is
 configured to play standalone.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{validateRhythm}
\item{\vskip -1.9ex 
\membername{validateRhythm}
{\tt protected boolean {\bf validateRhythm}(  )
\label{l382}\label{l383}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.Note}}{
\par{\small 
\refdefined{l20}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{duration}
{\tt public double {\bf duration}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Retrieves the duration of the note.
 
 Logs an exception if the note was not validated
 prior to playback.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The length of this note in milliseconds. 
}%end item
\end{itemize}
}%end item
\divideents{duration}
\item{\vskip -1.9ex 
\membername{duration}
{\tt protected void {\bf duration}( {\tt double } {\bf milliseconds} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the duration of the note. This value is sent out
 along the MIDI line to tell the ouput device how long
 to hold the note for.
 
 Can only be called by it's subclasses that deal with
 how long the note should be played for.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt milliseconds} - The new duration in milliseconds.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{evaluatedPitch}
\item{\vskip -1.9ex 
\membername{evaluatedPitch}
{\tt public Pitch {\bf evaluatedPitch}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A value for the calculated pitch. 
}%end item
\end{itemize}
}%end item
\divideents{evaluatePitch}
\item{\vskip -1.9ex 
\membername{evaluatePitch}
{\tt protected boolean {\bf evaluatePitch}( {\tt net.parallaxed.bluejam.JamParamters } {\bf params} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Evaluates this Note in the given JamParameters context.
 
 JamParameters supplies the root pitch. The actual pitch of 
 this note is supplied by 0 \textless  pitchRelative \textless  11, which is 
 added as an offset to the root pitch to give the real pitch.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt params} - The JamParameters context - passed from somewhere on high.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True on success, false on failure. 
}%end item
\end{itemize}
}%end item
\divideents{evaluatePitch}
\item{\vskip -1.9ex 
\membername{evaluatePitch}
{\tt public boolean {\bf evaluatePitch}( {\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
A note can be defined as "relative", in the context of 
 a given pitch and scale.
 
 If a note is relative, it will remain invalid until this
 method is called with some notion of context (i.e. a root
 pitch and a scale).
 
 This method will resolve the relative position of this note
 into an absolute pitch value.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rootPitch} - The root pitch to evaluate against}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{evaluateRhythm}
\item{\vskip -1.9ex 
\membername{evaluateRhythm}
{\tt public boolean {\bf evaluateRhythm}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf params} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Evaluates the rhythm of this note given the passed 
 SequenceParameters. These need to be passed in from 
 an implementation of Note.
 
 Error's will be sent to the default ErrorFeedback.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt params} - The given SequenceParameters ("context")}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
Whether the evaluation succeeded or not. 
}%end item
\end{itemize}
}%end item
\divideents{invalidate}
\item{\vskip -1.9ex 
\membername{invalidate}
{\tt protected void {\bf invalidate}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Marks this note as invalid.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{noteValue}
\item{\vskip -1.9ex 
\membername{noteValue}
{\tt public float {\bf noteValue}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
The MIDI note number of this note.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A float between 0 and 127 
}%end item
\end{itemize}
}%end item
\divideents{octave}
\item{\vskip -1.9ex 
\membername{octave}
{\tt public int {\bf octave}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns the octave number.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The octave the note is in 
}%end item
\end{itemize}
}%end item
\divideents{octave}
\item{\vskip -1.9ex 
\membername{octave}
{\tt public void {\bf octave}( {\tt int } {\bf octave} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the octave of this note if it can be 
 arbitrarily changed.
 
 Subclasses should override this to account for locks
 if necessary.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt octave} - The new octave number}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pitchClass}
\item{\vskip -1.9ex 
\membername{pitchClass}
{\tt public Pitch {\bf pitchClass}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The Pitch class of this note. 
}%end item
\end{itemize}
}%end item
\divideents{pitchClass}
\item{\vskip -1.9ex 
\membername{pitchClass}
{\tt public void {\bf pitchClass}( {\tt net.parallaxed.bluejam.Pitch } {\bf p} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Set the pitchClass of this note.
 
 Subclasses should override this fully to account for mutability
 of note properties.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} - The desired pitchClass}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pitchRelative}
\item{\vskip -1.9ex 
\membername{pitchRelative}
{\tt public int {\bf pitchRelative}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Used when pitch = Pitch.R to calculate the absolute pitch of the note.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The number of steps to this note from the root 
}%end item
\end{itemize}
}%end item
\divideents{pitchRelative}
\item{\vskip -1.9ex 
\membername{pitchRelative}
{\tt public void {\bf pitchRelative}( {\tt int } {\bf offset} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the pitch relative to the given root note + octave.
 
 Used when evaluating heuristic trees.
 
 If this number is negative, the root note is above the note
 If this number is positive, the root note is below the note
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt offset} - The number of steps (semitones) between the root note and this note.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{rest}
\item{\vskip -1.9ex 
\membername{rest}
{\tt public boolean {\bf rest}(  )
}%end signature
}%end item
\divideents{rhythm}
\item{\vskip -1.9ex 
\membername{rhythm}
{\tt public Rhythm {\bf rhythm}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Only accessed when initially adding this NoteLeaf to
 a NoteTree.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The rhythm of the note 
}%end item
\end{itemize}
}%end item
\divideents{rhythm}
\item{\vskip -1.9ex 
\membername{rhythm}
{\tt public void {\bf rhythm}( {\tt net.parallaxed.bluejam.Rhythm } {\bf r} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Only accessed when initially adding this NoteLeaf to
 a NoteTree.
 
 This method should be overridden (not just hidden) by classes
 that use locking.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{swingNote}
\item{\vskip -1.9ex 
\membername{swingNote}
{\tt public void {\bf swingNote}( {\tt int } {\bf swingPercent},
{\tt net.parallaxed.bluejam.Note } {\bf swingPartner} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Adds swing to a given note.
 
 A swing of 100\% is equivalent to a tied note.
 
 Swing is the act of pairing off two notes and then
 assigning a ratio to control their rhythmic value.
 
 This function will automatically assign the right 
 swing value to the partner note.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt swingPercent} - The amount of swing to assign to this note}
   \item{
\sld
{\tt swingPartner} - The swing partner of this note}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{swingPartner}
\item{\vskip -1.9ex 
\membername{swingPartner}
{\tt public Note {\bf swingPartner}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The note partnered with this one. 
}%end item
\end{itemize}
}%end item
\divideents{swingPercent}
\item{\vskip -1.9ex 
\membername{swingPercent}
{\tt public int {\bf swingPercent}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The percentage swing on this note (if any). 
}%end item
\end{itemize}
}%end item
\divideents{toggleRest}
\item{\vskip -1.9ex 
\membername{toggleRest}
{\tt public void {\bf toggleRest}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Toggles rest on$/$off.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{toggleRest}
\item{\vskip -1.9ex 
\membername{toggleRest}
{\tt public void {\bf toggleRest}( {\tt boolean } {\bf rest} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets this note to be a rest given the passed boolean.
 
 No information about the note is lost by turning it into
 a rest note. This can be undone at a later stage by calling
 toggleRest() again.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rest} - True turns this into a rest note, false reverts.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns true if this note is a rest
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{validateNotes}
\item{\vskip -1.9ex 
\membername{validateNotes}
{\tt public void {\bf validateNotes}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method validates the note and throws the 
 right kind of exception if anything is awry.
 
 For some reason this method uses lazy evaluation to
 optimize screen real-estate.
}%end item
  \end{itemize}
}
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.ValidationException} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{validatePitch}
\item{\vskip -1.9ex 
\membername{validatePitch}
{\tt protected boolean {\bf validatePitch}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Checks that the pitchClass field has a value and that
 the value is not relative.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
True if the criteria are met, false otherwise. 
}%end item
\end{itemize}
}%end item
\divideents{validateRhythm}
\item{\vskip -1.9ex 
\membername{validateRhythm}
{\tt protected boolean {\bf validateRhythm}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Checks the duration of this note (in milliseconds) is \textgreater  0.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
True if the criteria are met, false otherwise. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{NoteLeafSet}{l71}{%
{\small The note set of all possible pitch classes in the octave
 range supplied to the constructor.
 
 TODO Unit test for this...}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
NoteLeafSet}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.TerminalSet}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{NoteLeafSet}
{\tt public {\bf NoteLeafSet}(  )
\label{l384}\label{l385}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Trivial constructor does nothing if we're using one of
 the subclasses.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{NoteLeafSet}
\item{\vskip -1.9ex 
\membername{NoteLeafSet}
{\tt public {\bf NoteLeafSet}( {\tt int } {\bf minOctave},
{\tt int } {\bf maxOctave} )
\label{l386}\label{l387}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a NoteLeafSet constrained by octave range.
 
 Each range starts on A and ends on Ab, so a range of 
 4-5 yields all notes between A4-Ab5.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt minOctave} - }
   \item{
\sld
{\tt maxOctave} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Terminal } {\bf t} )
\label{l388}\label{l389}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Overrides the superclass' add function to ensure
 only NoteLeaf instances are added to this set.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public NoteLeaf {\bf getRandom}( {\tt net.parallaxed.bluejam.Note } {\bf n} )
\label{l390}\label{l391}}%end signature
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public NoteLeaf {\bf getRandom}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l392}\label{l393}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a random terminal that is likely to fit with
 the current model, knowing that the last terminal is 
 of a given pitch.
 
 Note that this only takes into consideration
 the very last note of the note sequence.
 
 If no model has been set, simply returns a terminal 
 from vanilla getRandom().
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The NoteSequence preceding the current note.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setModel}
\item{\vskip -1.9ex 
\membername{setModel}
{\tt public void {\bf setModel}( {\tt net.parallaxed.bluejam.grammar.PitchModel } {\bf model} )
\label{l394}\label{l395}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the model that this NoteLeaf set should
 use.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt model} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setRange}
\item{\vskip -1.9ex 
\membername{setRange}
{\tt public void {\bf setRange}( {\tt int } {\bf minOctave},
{\tt int } {\bf maxOctave} )
\label{l396}\label{l397}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the maximum range of the notes being played.
 
 maxOctave must be \textgreater = minOctave
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt minOctave} - }
   \item{
\sld
{\tt maxOctave} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.TerminalSet}}{
\par{\small 
\refdefined{l83}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Terminal } {\bf terminal} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns false if either the terminal supplied is null
 or the collection already contains the terminal.
 
 Otherwise, adds the item to the collection.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf o} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt o} - The Terminal to search for in this TerminalSet}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True if this set contains the passed Object 
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Terminal {\bf get}( {\tt int } {\bf index} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The index at which to look for the terminal.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
a terminal based on it's index in the set 
}%end item
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public Terminal {\bf getRandom}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A random terminal from the set. 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public Iterator {\bf iterator}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns an Iterator over the elements in this TerminalSet.
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt java.util.AbstractCollection.iterator()} {\small 
\refdefined{l398}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The number of terminals in this set. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractSet}}{
\par{\small 
\refdefined{l399}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractCollection}}{
\par{\small 
\refdefined{l152}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsAll}
\item{\vskip -1.9ex 
\membername{containsAll}
{\tt public boolean {\bf containsAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public abstract Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{retainAll}
\item{\vskip -1.9ex 
\membername{retainAll}
{\tt public boolean {\bf retainAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public abstract int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{NoteTree}{l72}{%
{\small Note trees are a data structure representing an unordered 
 tree of NoteSequences, itself forming a note sequence.
 
 Trees are walked and flattened into note sequences,
 representing a series of musical notes that make up a
 phrase.
 
 Depending on the player, the tree may be walked in different
 ways, so the order of the notes in the tree is fixed,
 but that fixed structure may be interpreted in all directions.
 
 Trees are a function, and by most definitions that function is
 isomorphic to "playing" the tree. When
 
 If the parent of a note tree is null, then the current node
 is determined to be the root of the tree. No other node in the
 tree should have a null parent.
 
 There are several operations that can happen to a NoteTree,
 remove(note), add(note) and swap(notesOut,notesIn). Add and remove 
 are self explanatory.
 
 Notes cannot be added in arbitrary positions yet, all added notes are
 appended to the node that executes the add operation.
 
 NoteTree instances may also be Heuristics, effectively 
 providing the "teaching" basics for the program, guiding 
 the solo in a certain direction. Evolution cycles may occur 
 with or without heuristic trees.
 
 Node arity is not limited, each add will create a new branch and
 the arity will increase.
 
 The arity of the note tree determines the rhythm of the 
 notes underneath it, so the position of node in a tree defines
 the duration of that node (not including alterations for 
 properties such as swing). 
 
 As a result of this, "rhythm" is not a property of notes, it is
 prescribed by the structure of the note sequence and evaluated at
 play time into the duration (long millisecs) property.
 
 TODO Change locking mechanism so the Heuristic locks are preserved.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
NoteTree}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
NoteSequence, Heuristic, Function, java.lang.Cloneable}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final int MAX\_DEPTH\begin{itemize}\item{\vskip -.9ex Rhythms below HEMIQUAVER are not supported, so the
 MAX\_DEPTH for any NoteTree is 8.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{NoteTree}
{\tt public {\bf NoteTree}(  )
\label{l400}\label{l401}}%end signature
}%end item
\divideents{NoteTree}
\item{\vskip -1.9ex 
\membername{NoteTree}
{\tt public {\bf NoteTree}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf parent} )
\label{l402}\label{l403}}%end signature
}%end item
\divideents{NoteTree}
\item{\vskip -1.9ex 
\membername{NoteTree}
{\tt public {\bf NoteTree}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf params} )
\label{l404}\label{l405}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
For instantiating a tree with custom parameters.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt params} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{acceptedRhythm}
{\tt public Rhythm {\bf acceptedRhythm}(  )
\label{l406}\label{l407}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The rhythm object that this tree will accept in an addNotes() call. 
}%end item
\end{itemize}
}%end item
\divideents{addNote}
\item{\vskip -1.9ex 
\membername{addNote}
{\tt protected boolean {\bf addNote}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf note},
{\tt int } {\bf childIndex} )
\label{l408}\label{l409}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Allows overriding behaviour, to add a note to a particular
 childIndex of a NoteTree. This method should only ever be 
 called by the parent, \_knowing\_ that the NoteTree is newly
 instantiated. 
 
 This forces out other children and can leave the tree
 unbalanced if used improperly.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt note} - The NoteLeaf to insert as a child of this node.}
   \item{
\sld
{\tt childIndex} - The index at which to insert this note.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{addNotes}
\item{\vskip -1.9ex 
\membername{addNotes}
{\tt public boolean {\bf addNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l410}\label{l411}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
 
 This function will add notes until the tree is full.
 
 Currently optimized to a lookahead depth of 2.
 
 
 $/$$/$ NB: THIS METHOD \_SHOULD\_ ONLY CALL ITSELF WITH A SINGLE NOTE
  - but it doesn't matter if there's more than 1...
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public NoteTree {\bf clone}(  )
\label{l412}\label{l413}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a cloned NoteTree.
 
 Every node in the note tree will be replaced by copies
 of those nodes (this method is recursive).
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A full copy of the note tree. 
}%end item
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l414}\label{l415}}%end signature
}%end item
\divideents{depth}
\item{\vskip -1.9ex 
\membername{depth}
{\tt public int {\bf depth}(  )
\label{l416}\label{l417}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The depth at which this NoteTree node exists relative to the root 
}%end item
\end{itemize}
}%end item
\divideents{getChild}
\item{\vskip -1.9ex 
\membername{getChild}
{\tt public NoteSequence {\bf getChild}( {\tt int } {\bf index} )
\label{l418}\label{l419}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The index at which to retrieve the child}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The child at the passed index 
}%end item
\end{itemize}
}%end item
\divideents{getCrossoverReferences}
\item{\vskip -1.9ex 
\membername{getCrossoverReferences}
{\tt public NoteSequence {\bf getCrossoverReferences}(  )
\label{l420}\label{l421}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Used during evolution to get all the references to NoteTree
 nodes that can undergo Crossover using the swapNotes() method.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An array of NoteSequenceInstances that are candidates for crossover. 
}%end item
\end{itemize}
}%end item
\divideents{getIncompleteReferences}
\item{\vskip -1.9ex 
\membername{getIncompleteReferences}
{\tt public NoteSequence {\bf getIncompleteReferences}(  )
\label{l422}\label{l423}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method returns an array of references to 
 nodes in the NoteTree with null children. 
 
 A reference is returned for each null child, so for
 NoteTrees with multiple empty children, multiple
 references will be returned.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An array of references to nodes with null children. 
}%end item
\end{itemize}
}%end item
\divideents{getMutationReferences}
\item{\vskip -1.9ex 
\membername{getMutationReferences}
{\tt public NoteLeaf {\bf getMutationReferences}(  )
\label{l424}\label{l425}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Used during evolution to get all the references we need
 to find nodes that can be mutated.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An array of NoteLeaf instances 
}%end item
\end{itemize}
}%end item
\divideents{getName}
\item{\vskip -1.9ex 
\membername{getName}
{\tt public String {\bf getName}(  )
\label{l426}\label{l427}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The name of this NoteTree (use toString()) 
}%end item
\end{itemize}
}%end item
\divideents{getNotes}
\item{\vskip -1.9ex 
\membername{getNotes}
{\tt public Iterator {\bf getNotes}(  )
\label{l428}\label{l429}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
 
 This determines how the note will be played.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getNoteSequence}
\item{\vskip -1.9ex 
\membername{getNoteSequence}
{\tt public NoteSequence {\bf getNoteSequence}(  )
\label{l430}\label{l431}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns the contents of the note tree (all notes that
 extend from the tree as children included). Included to 
 satisfy implementation of Function
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.Function} {\small 
\refdefined{l55}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getNumChildren}
\item{\vskip -1.9ex 
\membername{getNumChildren}
{\tt public int {\bf getNumChildren}(  )
\label{l432}\label{l433}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The number of children this node has 
}%end item
\end{itemize}
}%end item
\divideents{getSubTrees}
\item{\vskip -1.9ex 
\membername{getSubTrees}
{\tt public NoteSequence {\bf getSubTrees}(  )
\label{l434}\label{l435}}%end signature
}%end item
\divideents{parent}
\item{\vskip -1.9ex 
\membername{parent}
{\tt public NoteSequence {\bf parent}(  )
\label{l436}\label{l437}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The parent of this NoteSequence 
}%end item
\end{itemize}
}%end item
\divideents{removeNotes}
\item{\vskip -1.9ex 
\membername{removeNotes}
{\tt public void {\bf removeNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
\label{l438}\label{l439}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Deletes a branch from this Node and left-shifts
 all remaining children.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{rhythmDepth}
\item{\vskip -1.9ex 
\membername{rhythmDepth}
{\tt protected int {\bf rhythmDepth}( {\tt net.parallaxed.bluejam.Rhythm } {\bf r} )
\label{l440}\label{l441}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Tree depth is calculated by taking the logarithm
 of the rhythmic fraction to the base 2, and adding 1.
 
 i.e. 2$\wedge$3 = 8 (giving us depth 3 for a quaver).
 
 We add 1 to compensate for the total length of the phrase
 starting at depth 0 (tree root).
 
 This way, a whole note always starts at depth 1, not
 depth zero, since:
 
 2$\wedge$0 = 1 (giving us depth 0 for a whole note)
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt r} - A rhythm enum representing the value of the}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
An integer representing the tree depth. 
}%end item
\end{itemize}
}%end item
\divideents{sequenceParameters}
\item{\vskip -1.9ex 
\membername{sequenceParameters}
{\tt public SequenceParameters {\bf sequenceParameters}(  )
\label{l442}\label{l443}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{setSequenceParameters}
\item{\vskip -1.9ex 
\membername{setSequenceParameters}
{\tt public void {\bf setSequenceParameters}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters} )
\label{l444}\label{l445}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
To allow this to be a heuristic, we must be able to override it's
 SequenceParameters object (on construction), since
 NoteTrees are cloned from this and need to have a reference to
 it after cloning.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{swapNotes}
\item{\vskip -1.9ex 
\membername{swapNotes}
{\tt public boolean {\bf swapNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf swapOut},
{\tt net.parallaxed.bluejam.NoteSequence } {\bf swapIn} )
\label{l446}\label{l447}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Functions as a basic find$/$replace for tree mutations and
 other genetic operators like 1-point crossover.
 
 The first argument is searched for in the children of 
 this node, if that object it found, it is detached
 from it's parent and the swapIn parameter
 replaces it.
 
 Whatever method calls this should take care of setting
 placing the swapOut NoteSequence back in the right place.
 
 swapOut should be a reference to some node in this note tree.
 
 swapIn will be converted to a NoteTree if it is not already.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt swapOut} - The NoteSequence to replace in the tree.}
   \item{
\sld
{\tt swapIn} - The new NoteSequence to place in the position of swapIn.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{validateNotes}
\item{\vskip -1.9ex 
\membername{validateNotes}
{\tt public void {\bf validateNotes}(  )
\label{l448}\label{l449}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Simply calls validateNotes on all children and ensures
 their rhythms add up to \_sp.length whole notes.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{Pitch}{l73}{%
{\small This enumeration represents the pitches and can be used to
 determine enharmonic equivalence between pitch classes.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
Pitch}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final Pitch C\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Cs\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Db\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch D\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Ds\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Eb\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch E\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch F\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Fs\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Gb\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch G\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Gs\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Ab\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch A\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch As\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch Bb\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch B\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Pitch R\begin{itemize}\item{\vskip -.9ex R is a special kind of parameter, defining relative pitch. 
 It is used when loading up heuristic trees. 
 
 Notes can be locked at intervals from a given root pitch and,
 scale, but these are not known until the Heuristic is paired 
 with an individual in a population and initialized.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt net.parallaxed.bluejam.Pitch } {\bf p} )
\label{l450}\label{l451}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Determines enharmonic equivalence a given pitch.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} - The pitch to compare with}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
true if in the same pitch class i.e. (Cs,Db) = true. 
}%end item
\end{itemize}
}%end item
\divideents{eval}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final Accidental {\bf eval}(  )
\label{l452}\label{l453}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Evaluates which accidental is present on a given pitch.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
Accidental.SHARP for all Pitch.Xs and Accidental.FLAT for all Pitch.Xb 
}%end item
\end{itemize}
}%end item
\divideents{getName}
\item{\vskip -1.9ex 
\membername{getName}
{\tt public static final String {\bf getName}( {\tt net.parallaxed.bluejam.Pitch } {\bf pitch} )
\label{l454}\label{l455}}%end signature
}%end item
\divideents{getPitch}
\item{\vskip -1.9ex 
\membername{getPitch}
{\tt public static final Pitch {\bf getPitch}( {\tt java.lang.String } {\bf pitch} )
\label{l456}\label{l457}}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Pitch {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l458}\label{l459}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final Pitch {\bf values}(  )
\label{l460}\label{l461}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Population}{l74}{%
{\small The population class holds a collection of individuals and
 evolves them with or without a set of heuristics.
 
 Each evolution produces a new population of individuals,
 which are the product of mating that takes place between
 selected individuals in the prior population.
 
 Each new population can be thought of as another "generation".
 The best individuals (as evaluated by the fitness algorithms)
 should survive and in the final stages, producing a small set
 of candidates. One should be selected for output, and the others
 will be placed into the mating pool to produce the next generation.
 
 In the case of increased evaluation time on the second
 generation, another of the chosen solos from the first
 can be chosen. 
 
 A population may be instructed to destroy itself, in which case
 it returns a reference to the parent population and continues
 from there (see documentation on the interfaces).}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
Population}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public int memberCount\begin{itemize}\item{\vskip -.9ex Limit on the number of individuals in this population.}\end{itemize}
}
\item{
public Individual populous\begin{itemize}\item{\vskip -.9ex An array of fixed length, with a slot for each
 individual in the population.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Population}
{\tt public {\bf Population}( {\tt net.parallaxed.bluejam.Population } {\bf p} )
\label{l462}\label{l463}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a skeleton population given the passed population
 as a template. The constructed population will contain no
 individuals, but will reflect the parameters of the passed
 population.
 
 NB: Does not preserve the \_changed status of the given population.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} - The population to take as a template.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Population}
\item{\vskip -1.9ex 
\membername{Population}
{\tt public {\bf Population}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters} )
\label{l464}\label{l465}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a population.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt sequenceParameters} - The sequenceParameters to use in construction.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Population}
\item{\vskip -1.9ex 
\membername{Population}
{\tt public {\bf Population}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters},
{\tt int } {\bf memberCount} )
\label{l466}\label{l467}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a population.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt memberCount} - Maximum number of individuals in this population}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Population}
\item{\vskip -1.9ex 
\membername{Population}
{\tt public {\bf Population}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters},
{\tt int } {\bf memberCount},
{\tt net.parallaxed.bluejam.HeuristicCollection } {\bf heuristics} )
\label{l468}\label{l469}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a population.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt memberCount} - Maximum number of individuals in this population}
   \item{
\sld
{\tt heuristics} - Collection of heuristics to use while evolving this population}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{addHeuristic}
{\tt public void {\bf addHeuristic}( {\tt net.parallaxed.bluejam.Heuristic } {\bf heuristic} )
\label{l470}\label{l471}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Adds a heuristic to the population.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt heuristic} - The heuristic to be added}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{addIndividual}
\item{\vskip -1.9ex 
\membername{addIndividual}
{\tt public void {\bf addIndividual}( {\tt net.parallaxed.bluejam.Individual } {\bf i} )
\label{l472}\label{l473}}%end signature
}%end item
\divideents{addIndividuals}
\item{\vskip -1.9ex 
\membername{addIndividuals}
{\tt public void {\bf addIndividuals}( {\tt java.util.List } {\bf individuals} )
\label{l474}\label{l475}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Adds a list of individuals to the population.
 
 Throws IndividualAddException with any failed adds.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt individuals} - The individuals to add, in the order to add them.}
  \end{itemize}
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.IndividualAddException} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{buildHeuristic}
\item{\vskip -1.9ex 
\membername{buildHeuristic}
{\tt public Heuristic {\bf buildHeuristic}(  )
\label{l476}\label{l477}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Should be refactored to a utility method in EvolveHeuristic.
 
 Will take the MatingPool of candidates, and cycle through each
 candidate, taking a node from each.
 - Extend to first crossover point in the first tree, grab and add it 
 - Extend to second crossover point in the second tree, grab it ...
 - ... 
 
 Alternatively, just take the highest fitness individual in the
 pool.
 
 Finally, all notes should be changed to RELATIVE pitches, before 
 serializing out the file.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A new Heuristic. 
}%end item
\end{itemize}
}%end item
\divideents{evolve}
\item{\vskip -1.9ex 
\membername{evolve}
{\tt public Population {\bf evolve}(  )
\label{l478}\label{l479}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a reference to the evolved population
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A reference to the evolving thread. 
}%end item
\end{itemize}
}%end item
\divideents{getEmptySlots}
\item{\vskip -1.9ex 
\membername{getEmptySlots}
{\tt public ArrayList {\bf getEmptySlots}(  )
\label{l480}\label{l481}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns an ArrayList of integers with one entry for
 every empty slot in the populous array.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An ArrayList of [i] gaps in the populous, where populous[i] = null. 
}%end item
\end{itemize}
}%end item
\divideents{getFittestIndividual}
\item{\vskip -1.9ex 
\membername{getFittestIndividual}
{\tt public Individual {\bf getFittestIndividual}(  )
\label{l482}\label{l483}}%end signature
}%end item
\divideents{getIndividual}
\item{\vskip -1.9ex 
\membername{getIndividual}
{\tt public Individual {\bf getIndividual}( {\tt int } {\bf i} )
\label{l484}\label{l485}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns an individual given it's index in the
 population.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} - The index of this individual}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The individual at index i, or null. 
}%end item
\end{itemize}
}%end item
\divideents{getParameters}
\item{\vskip -1.9ex 
\membername{getParameters}
{\tt public PopulationParameters {\bf getParameters}(  )
\label{l486}\label{l487}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Retrieves a reference to the parameters of this population
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A ParameterCollection for this population 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.JamParamters} {\small 
\refdefined{l66}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getRandomIndividual}
\item{\vskip -1.9ex 
\membername{getRandomIndividual}
{\tt public Individual {\bf getRandomIndividual}(  )
\label{l488}\label{l489}}%end signature
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}(  )
\label{l490}\label{l491}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Initialises the population by creating the individuals
 and setting them with random values.
 
 Before calling this method, you must set the parameters
 for this population through setParameter(), or the hardcoded
 defaults will be used.
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.PopulationParameters} {\small 
\refdefined{l75}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{populationSize}
\item{\vskip -1.9ex 
\membername{populationSize}
{\tt public int {\bf populationSize}(  )
\label{l492}\label{l493}}%end signature
}%end item
\divideents{setParameter}
\item{\vskip -1.9ex 
\membername{setParameter}
{\tt public void {\bf setParameter}( {\tt java.lang.String } {\bf name},
{\tt java.lang.Object } {\bf value} )
\label{l494}\label{l495}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets a parameter for this population.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} - The name of the parameter to set}
   \item{
\sld
{\tt value} - An object of the correct type for this parameter}
  \end{itemize}
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.ParameterException} - }
  \end{itemize}
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.PopulationParameters} {\small 
\refdefined{l75}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{PopulationParameters}{l75}{%
{\small Provides a moderately strongly typed parameter collection
 for the population properties and constants.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
PopulationParameters}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final String SEQUENCE\begin{itemize}\item{\vskip -.9ex Default SequenceParams}\end{itemize}
}
\item{
public static final String SELECTION\_PRESSURE\begin{itemize}\item{\vskip -.9ex SelectionPressure parameter name.
 
 Value of this parameter must be an integer. This also defines the
 tournament size (if present).}\end{itemize}
}
\item{
public static final String SELECTION\_TYPE\begin{itemize}\item{\vskip -.9ex SelectionType parameter name.}\end{itemize}
}
\item{
public static final String HEURISTIC\_SELECTION\_TYPE\begin{itemize}\item{\vskip -.9ex SelectionType parameter name.}\end{itemize}
}
\item{
public static final String INITIALIZATION\_TYPE\begin{itemize}\item{\vskip -.9ex InitializationType parameter name.}\end{itemize}
}
\item{
public static final String FITNESS\_TYPE\begin{itemize}\item{\vskip -.9ex InitializationType parameter name.}\end{itemize}
}
\item{
public static final String GENOTYPE\begin{itemize}\item{\vskip -.9ex Genotype (Individual representation) parameter name.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{PopulationParameters}
{\tt public {\bf PopulationParameters}(  )
\label{l496}\label{l497}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Trivial Constructor
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{\_checkType}
{\tt protected boolean {\bf \_checkType}( {\tt java.lang.String } {\bf name},
{\tt java.lang.Object } {\bf value} )
\label{l498}\label{l499}}%end signature
}%end item
\divideents{getFitnessType}
\item{\vskip -1.9ex 
\membername{getFitnessType}
{\tt public FitnessType {\bf getFitnessType}(  )
\label{l500}\label{l501}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The FitnessType for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.FitnessType} {\small 
\refdefined{l191}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getGenotype}
\item{\vskip -1.9ex 
\membername{getGenotype}
{\tt public Genotype {\bf getGenotype}(  )
\label{l502}\label{l503}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The Genotype for this population 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.Genotype} {\small 
\refdefined{l192}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getInitializationType}
\item{\vskip -1.9ex 
\membername{getInitializationType}
{\tt public InitializationType {\bf getInitializationType}(  )
\label{l504}\label{l505}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The InitializationType for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.InitializationType} {\small 
\refdefined{l193}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getParameter}
\item{\vskip -1.9ex 
\membername{getParameter}
{\tt public Object {\bf getParameter}( {\tt java.lang.String } {\bf parameter} )
\label{l506}\label{l507}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
An object of the value of that parameter, or null if not found. 
}%end item
\end{itemize}
}%end item
\divideents{getSelectionPressure}
\item{\vskip -1.9ex 
\membername{getSelectionPressure}
{\tt public Integer {\bf getSelectionPressure}(  )
\label{l508}\label{l509}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The SelectionPressure for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.SelectTournament} {\small 
\refdefined{l194}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getSelectionType}
\item{\vskip -1.9ex 
\membername{getSelectionType}
{\tt public SelectionType {\bf getSelectionType}(  )
\label{l510}\label{l511}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The SelectionType for this population. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.SelectionType} {\small 
\refdefined{l195}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getSequenceParameters}
\item{\vskip -1.9ex 
\membername{getSequenceParameters}
{\tt public SequenceParameters {\bf getSequenceParameters}(  )
\label{l512}\label{l513}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
JamParameters can also be obtained through here.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The SequenceParameters instance used in this population. 
}%end item
\end{itemize}
}%end item
\divideents{setParameter}
\item{\vskip -1.9ex 
\membername{setParameter}
{\tt public void {\bf setParameter}( {\tt java.lang.String } {\bf name},
{\tt java.lang.Object } {\bf value} )
\label{l514}\label{l515}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets a parameter using moderately strict type checking.
 
 Value and name must both be non-null and supported by the
 Parameter collection type (either Individual or Population).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} - The name of the parameter to set}
   \item{
\sld
{\tt value} - The object value to set the parameter to.}
  \end{itemize}
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt net.parallaxed.bluejam.exceptions.ParameterException} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{Rhythm}{l76}{%
{\small This Enum contains all the rhythm's BlueJam supports.
 
 Consequently, the maximum depth of any NoteTree (in the
 default implementation) = the number of constants in this
 enum, plus 1 (currently, 8).}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
Rhythm}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final Rhythm SEMIBREVE\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Rhythm MINIM\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Rhythm CROTCHET\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Rhythm QUAVER\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Rhythm SEMIQUAVER\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Rhythm DEMIQUAVER\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final Rhythm HEMIQUAVER\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public int {\bf eval}(  )
\label{l516}\label{l517}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Return the reciprocal of the fraction represented by
 this rhythmic value.
 
 The reciprocal is 1$/$evalR().
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The denominator of the rhythmic fraction 
}%end item
\end{itemize}
}%end item
\divideents{evalR}
\item{\vskip -1.9ex 
\membername{evalR}
{\tt public float {\bf evalR}(  )
\label{l518}\label{l519}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Return the decimal fraction of a bar represented by
 this note in regular notation and a 4$/$4 time signature.
 
 Some hacks may be needed if using this to represent 
 an odd or irrational time signature, all others can 
 be calculated relative to these values.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A fraction representing that note's value. 
}%end item
\item{{\bf Exceptions}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.RuntimeException} - if there is no hardcoded value for that rhythm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getRhythm}
\item{\vskip -1.9ex 
\membername{getRhythm}
{\tt public static Rhythm {\bf getRhythm}( {\tt int } {\bf number} )
\label{l520}\label{l521}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Gets a rhythm given it's eval() value.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt number} - The eval() value of the rhythm (1$/$x)}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The Rhythm enumeration for the given number. 
}%end item
\end{itemize}
}%end item
\divideents{getRhythm}
\item{\vskip -1.9ex 
\membername{getRhythm}
{\tt public static Rhythm {\bf getRhythm}( {\tt java.lang.String } {\bf s} )
\label{l522}\label{l523}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns the rhythm matching the supplied name, e.g. "Semibreve",
 "Demiquaver" etc. 
 
 Case Insensitive.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} - The name of the rhythm}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The rhythm enumeration for the given name 
}%end item
\end{itemize}
}%end item
\divideents{increase}
\item{\vskip -1.9ex 
\membername{increase}
{\tt public Rhythm {\bf increase}( {\tt int } {\bf steps} )
\label{l524}\label{l525}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt steps} - The factor to increase the rhythm by (i.e. 1 doubles the rhythm, 2 triples, etc)}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
a new (augmented) rhythm, based on the number of steps. 
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Rhythm {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l526}\label{l527}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final Rhythm {\bf values}(  )
\label{l528}\label{l529}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Scale}{l77}{%
{\small This Enum describes how to produce each scale using stepped 
 jumps over pitch classes.
 
 Each encoding is minimal, and describes how to navigate
 from the root (I) through II-IV in the scale. VIII is the
 root repeated. 
 
 In the blues (I, bIII, IV, bV, V bVII), the flattened
 fifth seems traditionally noted as a "sharp" or natural 
 note. I don't know why this occurs but I see it everywhere.
 Therefore the accidental map for the blues notes the fourth
 as flat.
  
 Since bV (flat fifth) is enharmonic to IV\# (sharp fourth)
 in all cases I see no problem with re-implementing this 
 using flats only if desired. 
 
 This enum can also map accidentals.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public abstract 
class 
Scale}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Scale}
{\tt public {\bf Scale}(  )
\label{l530}\label{l531}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final int {\bf eval}(  )
\label{l532}\label{l533}}%end signature
}%end item
\divideents{eval}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public abstract Accidental {\bf eval}( {\tt net.parallaxed.bluejam.Pitch []} {\bf pitchClass},
{\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf noteNumber} )
\label{l534}\label{l535}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method provides a definite function call to find out
 which accidental should be present on a note.
 
 noteNumber is not strictly needed for this.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - The pitch class of the note.}
   \item{
\sld
{\tt noteNumber} - The note number, n, corresponds to accident[n]. The nth note in that scale.}
   \item{
\sld
{\tt rootPitch} - Passing in the root pitch reduces the calculation time.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The accidental of the note. 
}%end item
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt protected static Scale {\bf getInstance}(  )
\label{l536}\label{l537}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Singleton instance returning method which all subclasses
 must implement and make visible.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A scale of the type that has been instantiated. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{Scale.BLUES}{l78}{%
{\small Defines a blues scale with hexatonic pitch representation.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static final 
class 
Scale.BLUES}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.Scale}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final Accidental {\bf eval}( {\tt net.parallaxed.bluejam.Pitch []} {\bf pitchClass},
{\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf noteNumber} )
\label{l538}\label{l539}}%end signature
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static final Scale {\bf getInstance}(  )
\label{l540}\label{l541}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.Scale}}{
\par{\small 
\refdefined{l77}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final int {\bf eval}(  )
}%end signature
}%end item
\divideents{eval}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public abstract Accidental {\bf eval}( {\tt net.parallaxed.bluejam.Pitch []} {\bf pitchClass},
{\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf noteNumber} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method provides a definite function call to find out
 which accidental should be present on a note.
 
 noteNumber is not strictly needed for this.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - The pitch class of the note.}
   \item{
\sld
{\tt noteNumber} - The note number, n, corresponds to accident[n]. The nth note in that scale.}
   \item{
\sld
{\tt rootPitch} - Passing in the root pitch reduces the calculation time.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The accidental of the note. 
}%end item
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt protected static Scale {\bf getInstance}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Singleton instance returning method which all subclasses
 must implement and make visible.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A scale of the type that has been instantiated. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Scale.MAJOR}{l79}{%
{\small Defines a standard major scale.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static final 
class 
Scale.MAJOR}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.Scale}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Scale.MAJOR}
{\tt public {\bf Scale.MAJOR}(  )
\label{l542}\label{l543}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final Accidental {\bf eval}( {\tt net.parallaxed.bluejam.Pitch []} {\bf pitchClass},
{\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf noteNumber} )
\label{l544}\label{l545}}%end signature
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static final Scale {\bf getInstance}(  )
\label{l546}\label{l547}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.Scale}}{
\par{\small 
\refdefined{l77}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final int {\bf eval}(  )
}%end signature
}%end item
\divideents{eval}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public abstract Accidental {\bf eval}( {\tt net.parallaxed.bluejam.Pitch []} {\bf pitchClass},
{\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf noteNumber} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method provides a definite function call to find out
 which accidental should be present on a note.
 
 noteNumber is not strictly needed for this.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - The pitch class of the note.}
   \item{
\sld
{\tt noteNumber} - The note number, n, corresponds to accident[n]. The nth note in that scale.}
   \item{
\sld
{\tt rootPitch} - Passing in the root pitch reduces the calculation time.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The accidental of the note. 
}%end item
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt protected static Scale {\bf getInstance}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Singleton instance returning method which all subclasses
 must implement and make visible.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A scale of the type that has been instantiated. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Scale.MINOR}{l80}{%
{\small Defines a standard minor scale.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static final 
class 
Scale.MINOR}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.Scale}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Scale.MINOR}
{\tt public {\bf Scale.MINOR}(  )
\label{l548}\label{l549}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final Accidental {\bf eval}( {\tt net.parallaxed.bluejam.Pitch []} {\bf pitchClass},
{\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf noteNumber} )
\label{l550}\label{l551}}%end signature
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static final Scale {\bf getInstance}(  )
\label{l552}\label{l553}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.Scale}}{
\par{\small 
\refdefined{l77}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public final int {\bf eval}(  )
}%end signature
}%end item
\divideents{eval}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public abstract Accidental {\bf eval}( {\tt net.parallaxed.bluejam.Pitch []} {\bf pitchClass},
{\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt int } {\bf noteNumber} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method provides a definite function call to find out
 which accidental should be present on a note.
 
 noteNumber is not strictly needed for this.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pitchClass} - The pitch class of the note.}
   \item{
\sld
{\tt noteNumber} - The note number, n, corresponds to accident[n]. The nth note in that scale.}
   \item{
\sld
{\tt rootPitch} - Passing in the root pitch reduces the calculation time.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The accidental of the note. 
}%end item
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt protected static Scale {\bf getInstance}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Singleton instance returning method which all subclasses
 must implement and make visible.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A scale of the type that has been instantiated. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{ScaledSet}{l81}{%
{\small Given a set of rules for the scale, ScaledSet can work out 
 the set of notes that fit that scale, over a given number
 of octaves. A set of the chromatic notes in that scale 
 can also be produced.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
ScaledSet}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.NoteLeafSet}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public Pitch pitchClass\begin{itemize}\item{\vskip -.9ex This array describes pitch classes. Pitch classes encapsulate
 enharmonic notes and divide the pitches into orders of 12,
 which can then be used to calculate the given scale.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{ScaledSet}
{\tt public {\bf ScaledSet}( {\tt net.parallaxed.bluejam.Pitch } {\bf rootPitch},
{\tt net.parallaxed.bluejam.Scale } {\bf scale},
{\tt int } {\bf minOctave},
{\tt int } {\bf maxOctave} )
\label{l554}\label{l555}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Constructs a set of all notes of the right pitch over
 a given octave range and scale.
 
 Limits are always exclusive, so for Pitch.A on octaves 3-5
 will include A3, and all subsequent notes up to A6 (but not A6).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rootPitch} - The root pitch of the scale}
   \item{
\sld
{\tt scale} - The scale to use for generating notes}
   \item{
\sld
{\tt minOctave} - The lower 8ve limit}
   \item{
\sld
{\tt maxOctave} - The upper 8ve limit.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{addChromaticNote}
{\tt public boolean {\bf addChromaticNote}( {\tt net.parallaxed.bluejam.NoteLeaf } {\bf n} )
\label{l556}\label{l557}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Adds a chromatic note leaf to the set.
 TODO NOT IMPLEMENTED
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The Note to add to this scaled set}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
Whether the operation succeded or not. 
}%end item
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public NoteLeaf {\bf getRandom}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l558}\label{l559}}%end signature
}%end item
\divideents{octaveChangeProbability}
\item{\vskip -1.9ex 
\membername{octaveChangeProbability}
{\tt public int {\bf octaveChangeProbability}(  )
\label{l560}\label{l561}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The probability we will change from the current octave. 
}%end item
\end{itemize}
}%end item
\divideents{octaveChangeProbability}
\item{\vskip -1.9ex 
\membername{octaveChangeProbability}
{\tt public void {\bf octaveChangeProbability}( {\tt int } {\bf probability} )
\label{l562}\label{l563}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
If we're at the cusp of the next octave, here's the
 chance that we have of going up or down.
 TODO Include threshold for cusp.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt probability} - The probability of changes}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.NoteLeafSet}}{
\par{\small 
\refdefined{l71}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Terminal } {\bf t} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Overrides the superclass' add function to ensure
 only NoteLeaf instances are added to this set.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public NoteLeaf {\bf getRandom}( {\tt net.parallaxed.bluejam.Note } {\bf n} )
}%end signature
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public NoteLeaf {\bf getRandom}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a random terminal that is likely to fit with
 the current model, knowing that the last terminal is 
 of a given pitch.
 
 Note that this only takes into consideration
 the very last note of the note sequence.
 
 If no model has been set, simply returns a terminal 
 from vanilla getRandom().
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The NoteSequence preceding the current note.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setModel}
\item{\vskip -1.9ex 
\membername{setModel}
{\tt public void {\bf setModel}( {\tt net.parallaxed.bluejam.grammar.PitchModel } {\bf model} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the model that this NoteLeaf set should
 use.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt model} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setRange}
\item{\vskip -1.9ex 
\membername{setRange}
{\tt public void {\bf setRange}( {\tt int } {\bf minOctave},
{\tt int } {\bf maxOctave} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the maximum range of the notes being played.
 
 maxOctave must be \textgreater = minOctave
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt minOctave} - }
   \item{
\sld
{\tt maxOctave} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.TerminalSet}}{
\par{\small 
\refdefined{l83}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Terminal } {\bf terminal} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns false if either the terminal supplied is null
 or the collection already contains the terminal.
 
 Otherwise, adds the item to the collection.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf o} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt o} - The Terminal to search for in this TerminalSet}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True if this set contains the passed Object 
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Terminal {\bf get}( {\tt int } {\bf index} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The index at which to look for the terminal.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
a terminal based on it's index in the set 
}%end item
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public Terminal {\bf getRandom}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A random terminal from the set. 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public Iterator {\bf iterator}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns an Iterator over the elements in this TerminalSet.
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt java.util.AbstractCollection.iterator()} {\small 
\refdefined{l398}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The number of terminals in this set. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractSet}}{
\par{\small 
\refdefined{l399}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractCollection}}{
\par{\small 
\refdefined{l152}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsAll}
\item{\vskip -1.9ex 
\membername{containsAll}
{\tt public boolean {\bf containsAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public abstract Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{retainAll}
\item{\vskip -1.9ex 
\membername{retainAll}
{\tt public boolean {\bf retainAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public abstract int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{SequenceParameters}{l82}{%
{\small Currently, custom tree parameters aren't supported, so this
 default instantiation should cover the basics.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
SequenceParameters}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public volatile boolean Changed\begin{itemize}\item{\vskip -.9ex Has this SequenceParameters object been changed recently?}\end{itemize}
}
\item{
public JamParamters Jam\begin{itemize}\item{\vskip -.9ex The JamParameters for the current sequence.
 TODO Work on dynamic changing at runtime.}\end{itemize}
}
\item{
public int length\begin{itemize}\item{\vskip -.9ex The number of whole notes in this Sequence.
 
 i.e. 4 whole notes = 4 bars, so length=4}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{SequenceParameters}
{\tt public {\bf SequenceParameters}(  )
\label{l564}\label{l565}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Trivial SequenceParameters constructor.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{SequenceParameters}
\item{\vskip -1.9ex 
\membername{SequenceParameters}
{\tt public {\bf SequenceParameters}( {\tt net.parallaxed.bluejam.JamParamters } {\bf jam} )
\label{l566}\label{l567}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Initializes a set of SequenceParameters with the passed JamParameters
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt jam} - The JamParameters defining rootPitch, scale, etc.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{beatCount}
{\tt public int {\bf beatCount}(  )
\label{l568}\label{l569}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
The nominator of the time signature - the number of beat
 units per bar.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The number of beats per beat unit 
}%end item
\end{itemize}
}%end item
\divideents{beatUnit}
\item{\vskip -1.9ex 
\membername{beatUnit}
{\tt public int {\bf beatUnit}(  )
\label{l570}\label{l571}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
The beat unit is the denominator of the time signature.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
The note we measuring in (usually quarter-note, or Rhythm.CROTCHET) 
}%end item
\end{itemize}
}%end item
\divideents{timeSignature}
\item{\vskip -1.9ex 
\membername{timeSignature}
{\tt public String {\bf timeSignature}(  )
\label{l572}\label{l573}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The time signature of the sequence in string "x$/$y" format 
}%end item
\end{itemize}
}%end item
\divideents{timeSignature}
\item{\vskip -1.9ex 
\membername{timeSignature}
{\tt public void {\bf timeSignature}( {\tt java.lang.String } {\bf timeSignature} )
\label{l574}\label{l575}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Time signature is parsed to set the private variables
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{TerminalSet}{l83}{%
{\small Wraps an ArrayList to provide set-like functionality 
 (one unique instance per set).}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public abstract 
class 
TerminalSet}}
\noindent\hbox{\vbox{{\bf extends} java.util.AbstractSet}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{TerminalSet}
{\tt public {\bf TerminalSet}(  )
\label{l576}\label{l577}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Terminal } {\bf terminal} )
\label{l578}\label{l579}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns false if either the terminal supplied is null
 or the collection already contains the terminal.
 
 Otherwise, adds the item to the collection.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf o} )
\label{l580}\label{l581}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt o} - The Terminal to search for in this TerminalSet}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True if this set contains the passed Object 
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Terminal {\bf get}( {\tt int } {\bf index} )
\label{l582}\label{l583}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The index at which to look for the terminal.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
a terminal based on it's index in the set 
}%end item
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\membername{getRandom}
{\tt public Terminal {\bf getRandom}(  )
\label{l584}\label{l585}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A random terminal from the set. 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public Iterator {\bf iterator}(  )
\label{l586}\label{l587}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns an Iterator over the elements in this TerminalSet.
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt java.util.AbstractCollection.iterator()} {\small 
\refdefined{l398}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
\label{l588}\label{l589}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The number of terminals in this set. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractSet}}{
\par{\small 
\refdefined{l399}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractCollection}}{
\par{\small 
\refdefined{l152}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsAll}
\item{\vskip -1.9ex 
\membername{containsAll}
{\tt public boolean {\bf containsAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public abstract Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{retainAll}
\item{\vskip -1.9ex 
\membername{retainAll}
{\tt public boolean {\bf retainAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public abstract int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{TreeParser}{l84}{%
{\small This class reads in information from passed tree files,
 which normally represent a serialized layout of a NoteSequence.
 These files come in two flavours, .heuristic and .tree, each
 specifying roughly the same parameters. The different extension
 is merely a semantic pragma to inform the user what the file
 contains (a heuristic, or just a tree).
 
 .tree files may vary in what they contain, but they are normally serial stores
 of tree structures at a certain point in the evolution (they
 represent trees assigned to individuals) - or they are arbitrarily
 created files used for testing Tree parser provides only one method
 for accessing the parsed tree. The user can call getNoteTree() 
 and cast the result to whatever is desirable. Errors during parsing
 are printed out to the terminal.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
TreeParser}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{TreeParser}
{\tt public {\bf TreeParser}( {\tt java.io.File } {\bf treeFile} )
\label{l590}\label{l591}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Creates a TreeParser given a reference to a java.io.File object.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt treeFile} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{TreeParser}
\item{\vskip -1.9ex 
\membername{TreeParser}
{\tt public {\bf TreeParser}( {\tt java.lang.String } {\bf treeFile} )
\label{l592}\label{l593}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Creates a tree parser given a relative path.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt treeFile} - The file to parse.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getNoteTree}
{\tt public NoteTree {\bf getNoteTree}(  )
\label{l594}\label{l595}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The parsed note tree, can be cast to the desired type. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
}
}
\newpage
\def\packagename{net.parallaxed.bluejam.pd}
\chapter{\bf Package net.parallaxed.bluejam.pd}{
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Classes}
\entityintro{Configure}{l596}{Waits for a PD bang to kickstart the evolution and 
 playback of evolved solos.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
\newpage
\section{Classes}{
\startsection{Class}{Configure}{l596}{%
{\small Waits for a PD bang to kickstart the evolution and 
 playback of evolved solos. Also configures various parameters
 of the evolution before running the a generation.
  
 This object supports two modes - evolution and single file. In
 single file mode, the object is initialized with an 
 argument from PD, pointing to a tree file. The program loads
 this tree file and all subsequent playback will involve that
 tree file. The user can reload this single file after making
 changes to adjust the sound produced. This mode helps
 when designing heuristics, as the user can hear the programmed
 heuristic at any tempo and relative to any pitch.
 
 In evolution mode, the program loads all heuristics present in
 \$$\{$pd\_home$\}$$/$extra$/$bluejam$/$config (all .heuristic files), along
 with all models if present (...$/$model-\$$\{$PITCH$\}$.m), and 
 will run evolution cycles when triggered on or off.
 
 Custom scales are not supported (yet).
 TODO Stop errors from killing instantiation.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
Configure}}
\noindent\hbox{\vbox{{\bf extends} com.cycling74.max.MaxObject}}
\noindent\hbox{\vbox{{\bf implements} 
com.cycling74.max.Executable, net.parallaxed.bluejam.playback.Listener}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{Configure}
{\tt public {\bf Configure}(  )
\label{l597}\label{l598}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Instantiates the configuration to operate in evolution
 mode (no arguments).
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{Configure}
\item{\vskip -1.9ex 
\membername{Configure}
{\tt public {\bf Configure}( {\tt com.cycling74.max.Atom []} {\bf args} )
\label{l599}\label{l600}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
If constructed with arguments, only the supplied filename is played 
 (singleFileMode).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt args} - A string array of all arguments passed to the program, only args[0] is read.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{bang}
{\tt protected void {\bf bang}(  )
\label{l601}\label{l602}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This instructs the program to get ready and listen
 on the MIDI lines to detect a root pitch key.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{execute}
\item{\vskip -1.9ex 
\membername{execute}
{\tt public void {\bf execute}(  )
\label{l603}\label{l604}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Keeps the ball rolling; this function is called by
 the inner MaxClock. The delay of the MaxClock is set
 to the duration of the note.
 
 TODO - This is very primitive sequencing, could introduce separate clock for timing.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{inlet}
\item{\vskip -1.9ex 
\membername{inlet}
{\tt protected void {\bf inlet}( {\tt float } {\bf f} )
\label{l605}\label{l606}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Deals with floats arriving at inlets; parameters like
 populationSize, numberOfGenerations etc.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{listen}
\item{\vskip -1.9ex 
\membername{listen}
{\tt public void {\bf listen}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
\label{l607}\label{l608}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Queue's up a NoteSequence in the buffer and pre-meditatively
 evaluates it.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{reload}
\item{\vskip -1.9ex 
\membername{reload}
{\tt public void {\bf reload}(  )
\label{l609}\label{l610}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Reloads the file or completely restarts the evolution 
 if running.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt com.cycling74.max.MaxObject}}{
\par{\small 
\refdefined{l611}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{anything}
{\tt protected void {\bf anything}( {\tt java.lang.String } {\bf arg0},
{\tt com.cycling74.max.Atom []} {\bf arg1} )
}%end signature
}%end item
\divideents{bail}
\item{\vskip -1.9ex 
\membername{bail}
{\tt protected static void {\bf bail}( {\tt java.lang.String } {\bf arg0} )
}%end signature
}%end item
\divideents{bang}
\item{\vskip -1.9ex 
\membername{bang}
{\tt protected void {\bf bang}(  )
}%end signature
}%end item
\divideents{createInfoOutlet}
\item{\vskip -1.9ex 
\membername{createInfoOutlet}
{\tt protected void {\bf createInfoOutlet}( {\tt boolean } {\bf arg0} )
}%end signature
}%end item
\divideents{declareAttribute}
\item{\vskip -1.9ex 
\membername{declareAttribute}
{\tt protected void {\bf declareAttribute}( {\tt java.lang.String } {\bf arg0} )
}%end signature
}%end item
\divideents{declareInlets}
\item{\vskip -1.9ex 
\membername{declareInlets}
{\tt protected void {\bf declareInlets}( {\tt int []} {\bf arg0} )
}%end signature
}%end item
\divideents{declareIO}
\item{\vskip -1.9ex 
\membername{declareIO}
{\tt protected void {\bf declareIO}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{declareOutlets}
\item{\vskip -1.9ex 
\membername{declareOutlets}
{\tt protected void {\bf declareOutlets}( {\tt int []} {\bf arg0} )
}%end signature
}%end item
\divideents{declareReadOnlyAttribute}
\item{\vskip -1.9ex 
\membername{declareReadOnlyAttribute}
{\tt protected void {\bf declareReadOnlyAttribute}( {\tt java.lang.String } {\bf arg0} )
}%end signature
}%end item
\divideents{declareTypedIO}
\item{\vskip -1.9ex 
\membername{declareTypedIO}
{\tt protected void {\bf declareTypedIO}( {\tt java.lang.String } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\divideents{embedMessage}
\item{\vskip -1.9ex 
\membername{embedMessage}
{\tt protected void {\bf embedMessage}( {\tt java.lang.String } {\bf arg0},
{\tt com.cycling74.max.Atom []} {\bf arg1} )
}%end signature
}%end item
\divideents{error}
\item{\vskip -1.9ex 
\membername{error}
{\tt public static void {\bf error}( {\tt java.lang.String } {\bf arg0} )
}%end signature
}%end item
\divideents{gc}
\item{\vskip -1.9ex 
\membername{gc}
{\tt public void {\bf gc}(  )
}%end signature
}%end item
\divideents{getContext}
\item{\vskip -1.9ex 
\membername{getContext}
{\tt public static Object {\bf getContext}(  )
}%end signature
}%end item
\divideents{getErrorStream}
\item{\vskip -1.9ex 
\membername{getErrorStream}
{\tt public static ErrorStream {\bf getErrorStream}(  )
}%end signature
}%end item
\divideents{getInfoIdx}
\item{\vskip -1.9ex 
\membername{getInfoIdx}
{\tt public int {\bf getInfoIdx}(  )
}%end signature
}%end item
\divideents{getInlet}
\item{\vskip -1.9ex 
\membername{getInlet}
{\tt protected int {\bf getInlet}(  )
}%end signature
}%end item
\divideents{getInletType}
\item{\vskip -1.9ex 
\membername{getInletType}
{\tt public int {\bf getInletType}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{getName}
\item{\vskip -1.9ex 
\membername{getName}
{\tt public String {\bf getName}(  )
}%end signature
}%end item
\divideents{getNumInlets}
\item{\vskip -1.9ex 
\membername{getNumInlets}
{\tt public int {\bf getNumInlets}(  )
}%end signature
}%end item
\divideents{getNumOutlets}
\item{\vskip -1.9ex 
\membername{getNumOutlets}
{\tt public int {\bf getNumOutlets}(  )
}%end signature
}%end item
\divideents{getOutletType}
\item{\vskip -1.9ex 
\membername{getOutletType}
{\tt public int {\bf getOutletType}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{getParentPatcher}
\item{\vskip -1.9ex 
\membername{getParentPatcher}
{\tt public MaxPatcher {\bf getParentPatcher}(  )
}%end signature
}%end item
\divideents{getPostStream}
\item{\vskip -1.9ex 
\membername{getPostStream}
{\tt public static PostStream {\bf getPostStream}(  )
}%end signature
}%end item
\divideents{inlet}
\item{\vskip -1.9ex 
\membername{inlet}
{\tt protected void {\bf inlet}( {\tt float } {\bf arg0} )
}%end signature
}%end item
\divideents{inlet}
\item{\vskip -1.9ex 
\membername{inlet}
{\tt protected void {\bf inlet}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{list}
\item{\vskip -1.9ex 
\membername{list}
{\tt protected void {\bf list}( {\tt com.cycling74.max.Atom []} {\bf arg0} )
}%end signature
}%end item
\divideents{loadbang}
\item{\vskip -1.9ex 
\membername{loadbang}
{\tt protected void {\bf loadbang}(  )
}%end signature
}%end item
\divideents{notifyDeleted}
\item{\vskip -1.9ex 
\membername{notifyDeleted}
{\tt public void {\bf notifyDeleted}(  )
}%end signature
}%end item
\divideents{ouch}
\item{\vskip -1.9ex 
\membername{ouch}
{\tt public static void {\bf ouch}( {\tt java.lang.String } {\bf arg0} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt com.cycling74.max.Atom } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt com.cycling74.max.Atom []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt byte } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt byte []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt char } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt char []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt double } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt double []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt float } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt float []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt int []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt long } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt long []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt short } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt short []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt java.lang.String []} {\bf arg1} )
}%end signature
}%end item
\divideents{outlet}
\item{\vskip -1.9ex 
\membername{outlet}
{\tt public final boolean {\bf outlet}( {\tt int } {\bf arg0},
{\tt java.lang.String } {\bf arg1},
{\tt com.cycling74.max.Atom []} {\bf arg2} )
}%end signature
}%end item
\divideents{outletBang}
\item{\vskip -1.9ex 
\membername{outletBang}
{\tt public final boolean {\bf outletBang}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{outletBangHigh}
\item{\vskip -1.9ex 
\membername{outletBangHigh}
{\tt public final boolean {\bf outletBangHigh}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{outletHigh}
\item{\vskip -1.9ex 
\membername{outletHigh}
{\tt public final boolean {\bf outletHigh}( {\tt int } {\bf arg0},
{\tt com.cycling74.max.Atom []} {\bf arg1} )
}%end signature
}%end item
\divideents{outletHigh}
\item{\vskip -1.9ex 
\membername{outletHigh}
{\tt public final boolean {\bf outletHigh}( {\tt int } {\bf arg0},
{\tt double } {\bf arg1} )
}%end signature
}%end item
\divideents{outletHigh}
\item{\vskip -1.9ex 
\membername{outletHigh}
{\tt public final boolean {\bf outletHigh}( {\tt int } {\bf arg0},
{\tt float } {\bf arg1} )
}%end signature
}%end item
\divideents{outletHigh}
\item{\vskip -1.9ex 
\membername{outletHigh}
{\tt public final boolean {\bf outletHigh}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{outletHigh}
\item{\vskip -1.9ex 
\membername{outletHigh}
{\tt public final boolean {\bf outletHigh}( {\tt int } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\divideents{outletHigh}
\item{\vskip -1.9ex 
\membername{outletHigh}
{\tt public final boolean {\bf outletHigh}( {\tt int } {\bf arg0},
{\tt java.lang.String } {\bf arg1},
{\tt com.cycling74.max.Atom []} {\bf arg2} )
}%end signature
}%end item
\divideents{post}
\item{\vskip -1.9ex 
\membername{post}
{\tt public static void {\bf post}( {\tt java.lang.String } {\bf arg0} )
}%end signature
}%end item
\divideents{save}
\item{\vskip -1.9ex 
\membername{save}
{\tt protected void {\bf save}(  )
}%end signature
}%end item
\divideents{setInletAssist}
\item{\vskip -1.9ex 
\membername{setInletAssist}
{\tt protected void {\bf setInletAssist}( {\tt int } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\divideents{setInletAssist}
\item{\vskip -1.9ex 
\membername{setInletAssist}
{\tt protected void {\bf setInletAssist}( {\tt java.lang.String []} {\bf arg0} )
}%end signature
}%end item
\divideents{setName}
\item{\vskip -1.9ex 
\membername{setName}
{\tt public void {\bf setName}( {\tt java.lang.String } {\bf arg0} )
}%end signature
}%end item
\divideents{setOutletAssist}
\item{\vskip -1.9ex 
\membername{setOutletAssist}
{\tt protected void {\bf setOutletAssist}( {\tt int } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\divideents{setOutletAssist}
\item{\vskip -1.9ex 
\membername{setOutletAssist}
{\tt protected void {\bf setOutletAssist}( {\tt java.lang.String []} {\bf arg0} )
}%end signature
}%end item
\divideents{showException}
\item{\vskip -1.9ex 
\membername{showException}
{\tt public static void {\bf showException}( {\tt java.lang.String } {\bf arg0},
{\tt java.lang.Throwable } {\bf arg1} )
}%end signature
}%end item
\divideents{showException}
\item{\vskip -1.9ex 
\membername{showException}
{\tt public static void {\bf showException}( {\tt java.lang.Throwable } {\bf arg0} )
}%end signature
}%end item
\divideents{viewsource}
\item{\vskip -1.9ex 
\membername{viewsource}
{\tt public void {\bf viewsource}(  )
}%end signature
}%end item
\divideents{zap}
\item{\vskip -1.9ex 
\membername{zap}
{\tt public void {\bf zap}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
}
}
\newpage
\def\packagename{net.parallaxed.bluejam.evolution}
\chapter{\bf Package net.parallaxed.bluejam.evolution}{
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Interfaces}
\entityintro{Breeder}{l612}{Classes implementing this interface must fill a population
 to it's maximum capacity through the use of crossover
 and mutation to create new individuals.}
\entityintro{IndividualEvaluator}{l613}{Describes what arguments an implementing class
 (fitness function) must take.}
\entityintro{IndividualSelector}{l614}{Implementing classes should design selection algorithms
 that can accept a population as input, and produce another
 (skeleton) population as output.}
\entityintro{NoteSequenceInitializer}{l615}{Initializers are singletons that can accept a reference
 to a NoteSequence and fill it with notes using the algorithm
 they define.}
\vskip .13in
\hbox{\bf Classes}
\entityintro{FitnessContour}{l616}{Computes a fitness value for the contour of the 
 supplied NoteSequence.}
\entityintro{FitnessDistance}{l617}{Implements a measure of fitness by comparing the result
 of an individual to its original heuristic through 
 means analysing each note in the sequence to see
 that it is sufficiently displaced from those around
 it.}
\entityintro{FitnessInterval}{l618}{This class selects a random fitness method to apply.}
\entityintro{FitnessRandom}{l619}{Picks a random fitness evaluation method and returns
 the result.}
\entityintro{FitnessStacked}{l620}{Tracks which individuals have already been measured
 by the function, and applies different fitness measures
 each time.}
\entityintro{FitnessType}{l191}{Defines which types of fitness are available to
 the system.}
\entityintro{Genotype}{l192}{Names and stored reference to the underlying implementations
 of Genomes available in the system.}
\entityintro{HeuristicSelectionType}{l621}{When initializing the population, the set of loaded heuristics
 can be assigned randomly or evenly.}
\entityintro{InitializationType}{l193}{Defines the possible initialization types for the evolution
 process.}
\entityintro{InitializeGrow}{l622}{This form of the grow algorithm psuedorandomly selects 
 a rhythm with which to assign the note before adding
 it to the tree (having the effect of choosing all 
 functions down to that depth, and the final terminal).}
\entityintro{InitializeHeuristicTree}{l623}{Initializes note sequences using crossover on the heuristics, as
 defined by the TreeBreeder method, breed(NoteTree,NoteTree).}
\entityintro{InitializeRandom}{l624}{Implements a random initialization.}
\entityintro{NoteContext}{l625}{The NoteContext class is a wrapper for NoteCollection
 that gathers some information about that particular 
 collection of notes.}
\entityintro{NoteContext.Contour}{l626}{Contour defines the overall progression of a
 NoteSequence.}
\entityintro{PropertyFactory}{l627}{Defines which class sets properties for an Individual.}
\entityintro{RhythmInitializer}{l628}{Initializes Rhythm and other contextual properties for a passed 
 note sequence using a static probabilistic model.}
\entityintro{SelectionParameters}{l629}{This class follows a generic parameter pattern where the
 user can pass in parameters for the selection algorithm.}
\entityintro{SelectionType}{l195}{An enum containing the possible selection algorithms
 that can be used.}
\entityintro{SelectProportional}{l630}{Implements a proportional (Roulette Wheel) selection algorithm}
\entityintro{SelectTournament}{l194}{Performs a variant of tournament selection.}
\entityintro{TreeBreeder}{l631}{TreeBreeder is the default implementation of the Breeder
 interface for recombining and mutating NoteTrees, given 
 an initial skeletal population.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
\newpage
\section{Interfaces}{
\startsection{Interface}{Breeder}{l612}{%
{\small Classes implementing this interface must fill a population
 to it's maximum capacity through the use of crossover
 and mutation to create new individuals.
 
 The initial population passed to the function represents 
 the mating pool, so the algorithm should extract initial
 individuals from the referenced object.  If no population 
 is passed, this throws an exception. Nothing is returned 
 by implementing classes, the population referenced is 
 filled with children in-situ.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
Breeder}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{breed}
{\tt public void {\bf breed}( {\tt net.parallaxed.bluejam.Population } {\bf population} )
\label{l632}\label{l633}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Uses a skeletal population containing a collection
 of parents and fills up the population to the full
 memberCount quota using methods of crossover and mutation.
 
 Nothing should be returned by this method.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt population} - The population to breed.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{IndividualEvaluator}{l613}{%
{\small Describes what arguments an implementing class
 (fitness function) must take. Like the NoteSequenceInitializer interface, the evaluators
 assume a singleton implementation, whereby the NoteSequences
 to be evaluated are passed in through the evaluate() function.
 Evaluators are singletons and should not store any volatile 
 state in the class for ThreadSafety. NoteSequenceEvaluators may be optimized for different 
 dataTypes, but the default implementation of evaluate() should
 return {\it some} value for fitness, no matter what the 
 NoteSequence type is. In the default implementation, all fitness values are
 normalised (in the range0-1).
 
 The implementing should throw an exception if required
 knowledge of the dataType is not found, or output a warning
 if knowledge was expected but not present.The Selector function 
 however should be strictly compatible with the type of value 
 returned.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
IndividualEvaluator}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{evaluate}
{\tt public double {\bf evaluate}( {\tt net.parallaxed.bluejam.Individual } {\bf individual} )
\label{l634}\label{l635}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Evaluates the given NoteSequence in an individual, providing a double value
 for the fitness of that sequence.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt individual} - The Individual to Evaluate}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A value for the fitness of the NoteSequence 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.Individual} {\small 
\refdefined{l64}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{IndividualSelector}{l614}{%
{\small Implementing classes should design selection algorithms
 that can accept a population as input, and produce another
 (skeleton) population as output. These can be of an 
 arbitrary size, but a method to alter the size of the
 skeletal population should be provided. 
 
 Various breeding methods can be called over this subpopulation
 to flesh it out, before the selection procedure is
 called again to produce another generation of individuals.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
IndividualSelector}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{select}
{\tt public Population {\bf select}( {\tt net.parallaxed.bluejam.Population } {\bf pop},
{\tt int } {\bf numberOfIndividuals} )
\label{l636}\label{l637}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This function performs the selection, returning a
 smaller population as set by newPopulationCount(int).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pop} - The population to perform selection on.}
   \item{
\sld
{\tt numberOfIndividuals} - The number of individuals to select from the population.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A new population, ready to go into breeding. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Interface}{NoteSequenceInitializer}{l615}{%
{\small Initializers are singletons that can accept a reference
 to a NoteSequence and fill it with notes using the algorithm
 they define.
 
 Use of this interface separates knowledge of the algorithm 
 from the rest of the evolution.
 
 ***
 NB Since Initializers are singletons, they should all provide a 
 getInstance() method, which the framework will call to get a
 reference before it calls initialize()
 ***}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public interface 
NoteSequenceInitializer}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf params} )
\label{l638}\label{l639}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This method should fill up the note sequence, adding
 notes as appropriate. The algorithm implementation
 should be specific to the Genotype structure, so the
 implementing class should check that params
 supplies the right value for Genotype.
 
 
 
 Note that this method does not return anything, the
 NoteSequence will be altered appropriately after method
 execution.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The NoteSequence to initialize.}
   \item{
\sld
{\tt params} - The parameters specified for the individual that calls this method.}
  \end{itemize}
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.Genotype} {\small 
\refdefined{l192}}%end \small
}%end item
   \item{{\tt net.parallaxed.bluejam.NoteSequence} {\small 
\refdefined{l57}}%end \small
}%end item
   \item{{\tt net.parallaxed.bluejam.Note} {\small 
\refdefined{l20}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
}
\section{Classes}{
\startsection{Class}{FitnessContour}{l616}{%
{\small Computes a fitness value for the contour of the 
 supplied NoteSequence.
 
 This is optimised to work with NoteTree, but will
 return a value for sequences that are not NoteTrees.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
FitnessContour}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
IndividualEvaluator}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{evaluate}
{\tt public double {\bf evaluate}( {\tt net.parallaxed.bluejam.Individual } {\bf individual} )
\label{l640}\label{l641}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static FitnessContour {\bf getInstance}(  )
\label{l642}\label{l643}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{FitnessDistance}{l617}{%
{\small Implements a measure of fitness by comparing the result
 of an individual to its original heuristic through 
 means analysing each note in the sequence to see
 that it is sufficiently displaced from those around
 it. The bracket of notes that are examined is defined by the
 DistanceThreshold, so for one note either side (the default)
 that's 3.
 
 The final fitness score is given by adding up the measure
 of how similar the final output is, then taking the 
 logarithm of that score before putting it into a function
 to get the final fitness value.
 
 To give an idea of numbers, a similarity score of about 
 300-400 is virtually identical, 200-300 is too similar,
 100-200 is similar, 50-100 is good, 10-50 is good but getting
 dissimilar, 0-10 is unrecognisable from the original
 heuristic. We should start generating new heuristics if this measure
 is returning the maximum possible fitness.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
FitnessDistance}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
IndividualEvaluator}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{evaluate}
{\tt public double {\bf evaluate}( {\tt net.parallaxed.bluejam.Individual } {\bf individual} )
\label{l644}\label{l645}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Compare each note in the Sequence property for property.
 
 Use a minimal threshold distance to check if the properties
 are shared either side.
 
 If properties are shared, we increment the score. If the 
 properties are shared at the midpoint of the window defined 
 by DistanceThreshold, we increment the score again.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static FitnessDistance {\bf getInstance}(  )
\label{l646}\label{l647}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The singleton instance of FitnessDistance 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{FitnessInterval}{l618}{%
{\small This class selects a random fitness method to apply.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
FitnessInterval}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
IndividualEvaluator}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static int IntervalWindow\begin{itemize}\item{\vskip -.9ex How many repetitions before we start to reduce the fitness?}\end{itemize}
}
\item{
public static int BackoffPercent\begin{itemize}\item{\vskip -.9ex Defines how many cases of repetition should be "let through"}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{evaluate}
{\tt public double {\bf evaluate}( {\tt net.parallaxed.bluejam.Individual } {\bf individual} )
\label{l648}\label{l649}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
 
 The way to evaluate intervals is simply to skip over the
 noteSequence and find out how many notes have interval \textgreater  3.
 
 This is acceptable in a few contexts, and octave jumps
 are permitted (in few amounts)
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static FitnessInterval {\bf getInstance}(  )
\label{l650}\label{l651}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
An instance of the FitnessInterval Evaluator 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{FitnessRandom}{l619}{%
{\small Picks a random fitness evaluation method and returns
 the result.
 
 This is not used in the default implementation of BlueJam.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
FitnessRandom}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
IndividualEvaluator}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{evaluate}
{\tt public double {\bf evaluate}( {\tt net.parallaxed.bluejam.Individual } {\bf individual} )
\label{l652}\label{l653}}%end signature
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static FitnessRandom {\bf getInstance}(  )
\label{l654}\label{l655}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{FitnessStacked}{l620}{%
{\small Tracks which individuals have already been measured
 by the function, and applies different fitness measures
 each time.
 
 This class compounds various fitness methods.
 
 INTERVALS
 -\textgreater 
 HEURISTIC-DIFFERENCE
 -\textgreater 
 CONTOUR
 
 One problem with this might be that individuals
 with a propensity for only one thing will be discarded,
 and never make it to the mating pool, where they 
 may have very good genes for accomplishing a
 particular task.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
FitnessStacked}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
IndividualEvaluator}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{evaluate}
{\tt public double {\bf evaluate}( {\tt net.parallaxed.bluejam.Individual } {\bf individual} )
\label{l656}\label{l657}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{getInstance}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static FitnessStacked {\bf getInstance}(  )
\label{l658}\label{l659}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
An instance of FitnessStacked. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{FitnessType}{l191}{%
{\small Defines which types of fitness are available to
 the system.
 
 This parameter is also specified by default in
 PopulationParameters. Different Individuals can use
 distinct fitness measures if they wish.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
FitnessType}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private Class \_impl\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final FitnessType STACKED\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final FitnessType RANDOM\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final FitnessType INTERVAL\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final FitnessType CONTOUR\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final FitnessType DISTANCE\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public Class {\bf eval}(  )
\label{l660}\label{l661}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The implementing class. 
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static FitnessType {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l662}\label{l663}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final FitnessType {\bf values}(  )
\label{l664}\label{l665}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{Genotype}{l192}{%
{\small Names and stored reference to the underlying implementations
 of Genomes available in the system.
 
 The default is a NoteTree.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
Genotype}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private Class \_genotypeImpl\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final Genotype NOTE\_TREE\begin{itemize}\item{\vskip -.9ex The default genome implementation.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public Class {\bf eval}(  )
\label{l666}\label{l667}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a refernece to the class for the implementing
 genome type. This type *must* implement NoteSequence, or
 undefined behaviour will occur.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
A parameterizable Class instance for the enumerable genotype. 
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Genotype {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l668}\label{l669}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final Genotype {\bf values}(  )
\label{l670}\label{l671}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{HeuristicSelectionType}{l621}{%
{\small When initializing the population, the set of loaded heuristics
 can be assigned randomly or evenly. HeuristicSelectionType.EVEN
 will iterate through the list, whereas HeuristicSelectionType.RANDOM
 will pick any from the list.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
HeuristicSelectionType}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final HeuristicSelectionType EVEN\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
public static final HeuristicSelectionType RANDOM\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static HeuristicSelectionType {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l672}\label{l673}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final HeuristicSelectionType {\bf values}(  )
\label{l674}\label{l675}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{InitializationType}{l193}{%
{\small Defines the possible initialization types for the evolution
 process.
 
 To add a new Initialization algorithm, create the class
 and define it here, then you can specify the enum value in
 PopulationParameters.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
InitializationType}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private Class \_initImpl\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final InitializationType RANDOM\begin{itemize}\item{\vskip -.9ex Random initialization}\end{itemize}
}
\item{
public static final InitializationType GROW\begin{itemize}\item{\vskip -.9ex Grow initialization}\end{itemize}
}
\item{
public static final InitializationType HEURISTIC\begin{itemize}\item{\vskip -.9ex Contoured initialization}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public Class {\bf eval}(  )
\label{l676}\label{l677}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The implementing class. 
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static InitializationType {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l678}\label{l679}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final InitializationType {\bf values}(  )
\label{l680}\label{l681}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{InitializeGrow}{l622}{%
{\small This form of the grow algorithm psuedorandomly selects 
 a rhythm with which to assign the note before adding
 it to the tree (having the effect of choosing all 
 functions down to that depth, and the final terminal).}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
InitializeGrow}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
NoteSequenceInitializer}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static InitializeGrow {\bf getInstance}(  )
\label{l682}\label{l683}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
An Instance of the "Grow" initialization algorithm. 
}%end item
\end{itemize}
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf params} )
\label{l684}\label{l685}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{InitializeHeuristicTree}{l623}{%
{\small Initializes note sequences using crossover on the heuristics, as
 defined by the TreeBreeder method, breed(NoteTree,NoteTree).
 
 This initializer performs crossover on the NoteSequences
 passed to it (which are clones of the Heuristics, if present).
 
 On the first call of the function, the passed NoteSequence is
 stored in the Initializer. On the second call, crossover is
 performed and the memory of the Initializer is erased.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
InitializeHeuristicTree}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
NoteSequenceInitializer}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static InitializeHeuristicTree {\bf getInstance}(  )
\label{l686}\label{l687}}%end signature
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf params} )
\label{l688}\label{l689}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
 
 Satisfies implementation of NoteSequenceInitializer.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{InitializeRandom}{l624}{%
{\small Implements a random initialization. This initially fills the
 tree out to crotchet depth, then randomly selects 
 
 This is not a true FULL method, it is adapted to function 
 better given the musical domain.
 
 In this case we fill out to a LIMIT max-depth (normally 
 Rhythm.CROTCHET), and grow the rest.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
InitializeRandom}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
NoteSequenceInitializer}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static InitializeRandom {\bf getInstance}(  )
\label{l690}\label{l691}}%end signature
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf params} )
\label{l692}\label{l693}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{NoteContext}{l625}{%
{\small The NoteContext class is a wrapper for NoteCollection
 that gathers some information about that particular 
 collection of notes.
 
 NoteContext also provides the Contour enum.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
NoteContext}}
\noindent\hbox{\vbox{{\bf extends} net.parallaxed.bluejam.NoteCollection}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private boolean \_changed\begin{itemize}\item{\vskip -.9ex Has this context been changed?}\end{itemize}
}
\item{
private int \_contourThreshold\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\item{
private NoteContext.Contour \_contour\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{NoteContext}
{\tt public {\bf NoteContext}( {\tt net.parallaxed.bluejam.SequenceParameters } {\bf sequenceParameters} )
\label{l694}\label{l695}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Instantiates a NoteContext.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public void {\bf add}( {\tt int } {\bf index},
{\tt net.parallaxed.bluejam.Note } {\bf element} )
\label{l696}\label{l697}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Note } {\bf element} )
\label{l698}\label{l699}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
\label{l700}\label{l701}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{contour}
\item{\vskip -1.9ex 
\membername{contour}
{\tt public NoteContext.Contour {\bf contour}(  )
\label{l702}\label{l703}}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Note {\bf remove}( {\tt int } {\bf index} )
\label{l704}\label{l705}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf o} )
\label{l706}\label{l707}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt net.parallaxed.bluejam.NoteCollection}}{
\par{\small 
\refdefined{l69}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt net.parallaxed.bluejam.Note } {\bf n} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Will check if a passed note has an ID, if so
 it will also be added to an internal HashMap for
 later retrieval.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{addNotes}
\item{\vskip -1.9ex 
\membername{addNotes}
{\tt public boolean {\bf addNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Appends the passed NoteSeqeunce to the NoteCollection.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The notes to be appended.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
Always true for this implementation. 
}%end item
\end{itemize}
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public NoteCollection {\bf clone}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
NoteCollections are note cloneable (...yet)
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf n} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} - The NoteSequence to search for}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
True if this collection contains the passed NoteSequence. 
}%end item
\end{itemize}
}%end item
\divideents{crop}
\item{\vskip -1.9ex 
\membername{crop}
{\tt public NoteCollection {\bf crop}( {\tt int } {\bf index} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Crops a noteCollection returning all elements from the
 specified index to the end of the collection.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The note index where the crop begins}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A cropped copy of this NoteCollection 
}%end item
\end{itemize}
}%end item
\divideents{crop}
\item{\vskip -1.9ex 
\membername{crop}
{\tt public NoteCollection {\bf crop}( {\tt int } {\bf index},
{\tt int } {\bf end} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Crops a noteCollection returning all elements from the
 specified index to the point specified.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The note index where the crop begins}
   \item{
\sld
{\tt end} - Where to stop the crop.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
A cropped copy of this NoteCollection 
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Note {\bf get}( {\tt int } {\bf index} )
}%end signature
}%end item
\divideents{getIndex}
\item{\vskip -1.9ex 
\membername{getIndex}
{\tt public Note {\bf getIndex}( {\tt int } {\bf index} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
To preserve original functionality, this simply calls the superclass get()
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} - The index to retrieve.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The note at index. 
}%end item
\end{itemize}
}%end item
\divideents{getNotes}
\item{\vskip -1.9ex 
\membername{getNotes}
{\tt public Iterator {\bf getNotes}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An iterator over this NoteCollection 
}%end item
\end{itemize}
}%end item
\divideents{removeNotes}
\item{\vskip -1.9ex 
\membername{removeNotes}
{\tt public void {\bf removeNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.NoteSequence} {\small 
\refdefined{l57}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sequenceParameters}
\item{\vskip -1.9ex 
\membername{sequenceParameters}
{\tt public SequenceParameters {\bf sequenceParameters}(  )
}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A reference to this NoteCollection's SequenceParameters. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.SequenceParameters} {\small 
\refdefined{l82}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{swapNotes}
\item{\vskip -1.9ex 
\membername{swapNotes}
{\tt public boolean {\bf swapNotes}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf swapOut},
{\tt net.parallaxed.bluejam.NoteSequence } {\bf swapIn} )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.NoteSequence} {\small 
\refdefined{l57}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{validateNotes}
\item{\vskip -1.9ex 
\membername{validateNotes}
{\tt public void {\bf validateNotes}(  )
}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Attempts to call validateNotes() on all it's children.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.ArrayList}}{
\par{\small 
\refdefined{l150}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public void {\bf add}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt int } {\bf arg0},
{\tt java.util.Collection } {\bf arg1} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public Object {\bf clone}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{ensureCapacity}
\item{\vskip -1.9ex 
\membername{ensureCapacity}
{\tt public void {\bf ensureCapacity}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Object {\bf get}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{indexOf}
\item{\vskip -1.9ex 
\membername{indexOf}
{\tt public int {\bf indexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{lastIndexOf}
\item{\vskip -1.9ex 
\membername{lastIndexOf}
{\tt public int {\bf lastIndexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeRange}
\item{\vskip -1.9ex 
\membername{removeRange}
{\tt protected void {\bf removeRange}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\membername{set}
{\tt public Object {\bf set}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{trimToSize}
\item{\vskip -1.9ex 
\membername{trimToSize}
{\tt public void {\bf trimToSize}(  )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractList}}{
\par{\small 
\refdefined{l151}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\membername{add}
{\tt public void {\bf add}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt int } {\bf arg0},
{\tt java.util.Collection } {\bf arg1} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public abstract Object {\bf get}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{indexOf}
\item{\vskip -1.9ex 
\membername{indexOf}
{\tt public int {\bf indexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{lastIndexOf}
\item{\vskip -1.9ex 
\membername{lastIndexOf}
{\tt public int {\bf lastIndexOf}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{listIterator}
\item{\vskip -1.9ex 
\membername{listIterator}
{\tt public ListIterator {\bf listIterator}(  )
}%end signature
}%end item
\divideents{listIterator}
\item{\vskip -1.9ex 
\membername{listIterator}
{\tt public ListIterator {\bf listIterator}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt int } {\bf arg0} )
}%end signature
}%end item
\divideents{removeRange}
\item{\vskip -1.9ex 
\membername{removeRange}
{\tt protected void {\bf removeRange}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\membername{set}
{\tt public Object {\bf set}( {\tt int } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{subList}
\item{\vskip -1.9ex 
\membername{subList}
{\tt public List {\bf subList}( {\tt int } {\bf arg0},
{\tt int } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractCollection}}{
\par{\small 
\refdefined{l152}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{add}
{\tt public boolean {\bf add}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{addAll}
\item{\vskip -1.9ex 
\membername{addAll}
{\tt public boolean {\bf addAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{clear}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\membername{contains}
{\tt public boolean {\bf contains}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsAll}
\item{\vskip -1.9ex 
\membername{containsAll}
{\tt public boolean {\bf containsAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\membername{iterator}
{\tt public abstract Iterator {\bf iterator}(  )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public boolean {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{removeAll}
\item{\vskip -1.9ex 
\membername{removeAll}
{\tt public boolean {\bf removeAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{retainAll}
\item{\vskip -1.9ex 
\membername{retainAll}
{\tt public boolean {\bf retainAll}( {\tt java.util.Collection } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public abstract int {\bf size}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}(  )
}%end signature
}%end item
\divideents{toArray}
\item{\vskip -1.9ex 
\membername{toArray}
{\tt public Object {\bf toArray}( {\tt java.lang.Object []} {\bf arg0} )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{NoteContext.Contour}{l626}{%
{\small Contour defines the overall progression of a
 NoteSequence. This is calculated using a minimum
 number of notes called the "contour threshold".
 
 If the calculating context has less notes than
 the contour threshold, no contour can be assigned.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public static final 
class 
NoteContext.Contour}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final NoteContext.Contour UP\begin{itemize}\item{\vskip -.9ex A NoteSequence that predominantly goes upward}\end{itemize}
}
\item{
public static final NoteContext.Contour DOWN\begin{itemize}\item{\vskip -.9ex A NoteSequence that predominantly goes downward}\end{itemize}
}
\item{
public static final NoteContext.Contour NONE\begin{itemize}\item{\vskip -.9ex A NoteSequence that does not have a predominant direction.}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static NoteContext.Contour {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l708}\label{l709}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final NoteContext.Contour {\bf values}(  )
\label{l710}\label{l711}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{PropertyFactory}{l627}{%
{\small Defines which class sets properties for an Individual.
 
 Other implementations may be devised and placed in the enum.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
PropertyFactory}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private Class \_initImpl\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final PropertyFactory RHYTHM\_INITIALIZER\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public Class {\bf eval}(  )
\label{l712}\label{l713}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns the implementing class.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
 
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static PropertyFactory {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l714}\label{l715}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final PropertyFactory {\bf values}(  )
\label{l716}\label{l717}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{RhythmInitializer}{l628}{%
{\small Initializes Rhythm and other contextual properties for a passed 
 note sequence using a static probabilistic model.
 
 This Initializer will track the context in which it is being 
 initialized, which should aid the evolution by producing
 programs which are more likely to follow a musically "fit"
 pattern, rather than being completely random. This is because our
 initial population size is comparatively quite small, and we 
 need to guarantee a short termination time.
 
 This implementation keeps track of context (i.e. tracks the
 last notes that were added), assigning properties based
 on notes that have been processed since the last clearContext()
 call.
 
 This implementation is BIASED towards returning Quavers.
 Other implementations can take on any other desirable bias.
 
 Specialised to NoteTree implementation - will call 
 getAcceptedRhythm() to validate the added rhythm.
 
 TODO Dynamic rhythm probabilities.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
RhythmInitializer}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
NoteSequenceInitializer}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static RhythmInitializer {\bf getInstance}(  )
\label{l718}\label{l719}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
An instance of the PropertyInitializer 
}%end item
\end{itemize}
}%end item
\divideents{getNextRhythm}
\item{\vskip -1.9ex 
\membername{getNextRhythm}
{\tt public static Rhythm {\bf getNextRhythm}(  )
\label{l720}\label{l721}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Returns a rhythm from the distribution specified by
 the static initializers of this class.
}%end item
  \end{itemize}
}
\item{{\bf Returns} - 
An instance of Rhythm 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.Rhythm} {\small 
\refdefined{l76}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}( {\tt net.parallaxed.bluejam.NoteSequence } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf params} )
\label{l722}\label{l723}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Initializes properties of Rhythm.
 
 Default implementation initializes rhythm and swing on
 the passed NoteSequence.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\membername{initialize}
{\tt public void {\bf initialize}( {\tt net.parallaxed.bluejam.NoteTree } {\bf notes},
{\tt net.parallaxed.bluejam.PopulationParameters } {\bf params} )
\label{l724}\label{l725}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
This function does the same as a regular initialize() but does not
 assign arbitrary rhythms to the sequence.
 TODO Refactor duplicated code.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt notes} - The notes to initialize}
   \item{
\sld
{\tt params} - The PopulationParameters to use.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{SelectionParameters}{l629}{%
{\small This class follows a generic parameter pattern where the
 user can pass in parameters for the selection algorithm.
 
 In the default BlueJam implementation this is only used to
 pass in TournamentSize to SelectTournament.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
SelectionParameters}}
\noindent\hbox{\vbox{{\bf extends} java.util.HashMap}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{SelectionParameters}
{\tt public {\bf SelectionParameters}(  )
\label{l726}\label{l727}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.util.HashMap}}{
\par{\small 
\refdefined{l53}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt public Object {\bf clone}(  )
}%end signature
}%end item
\divideents{containsKey}
\item{\vskip -1.9ex 
\membername{containsKey}
{\tt public boolean {\bf containsKey}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsValue}
\item{\vskip -1.9ex 
\membername{containsValue}
{\tt public boolean {\bf containsValue}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{entrySet}
\item{\vskip -1.9ex 
\membername{entrySet}
{\tt public Set {\bf entrySet}(  )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Object {\bf get}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{keySet}
\item{\vskip -1.9ex 
\membername{keySet}
{\tt public Set {\bf keySet}(  )
}%end signature
}%end item
\divideents{put}
\item{\vskip -1.9ex 
\membername{put}
{\tt public Object {\bf put}( {\tt java.lang.Object } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{putAll}
\item{\vskip -1.9ex 
\membername{putAll}
{\tt public void {\bf putAll}( {\tt java.util.Map } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public Collection {\bf values}(  )
}%end signature
}%end item
\end{itemize}
}}
\startsubsubsection{Methods inherited from class {\tt java.util.AbstractMap}}{
\par{\small 
\refdefined{l54}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clear}
{\tt public void {\bf clear}(  )
}%end signature
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected Object {\bf clone}(  )
}%end signature
}%end item
\divideents{containsKey}
\item{\vskip -1.9ex 
\membername{containsKey}
{\tt public boolean {\bf containsKey}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{containsValue}
\item{\vskip -1.9ex 
\membername{containsValue}
{\tt public boolean {\bf containsValue}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{entrySet}
\item{\vskip -1.9ex 
\membername{entrySet}
{\tt public abstract Set {\bf entrySet}(  )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\membername{get}
{\tt public Object {\bf get}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{isEmpty}
\item{\vskip -1.9ex 
\membername{isEmpty}
{\tt public boolean {\bf isEmpty}(  )
}%end signature
}%end item
\divideents{keySet}
\item{\vskip -1.9ex 
\membername{keySet}
{\tt public Set {\bf keySet}(  )
}%end signature
}%end item
\divideents{put}
\item{\vskip -1.9ex 
\membername{put}
{\tt public Object {\bf put}( {\tt java.lang.Object } {\bf arg0},
{\tt java.lang.Object } {\bf arg1} )
}%end signature
}%end item
\divideents{putAll}
\item{\vskip -1.9ex 
\membername{putAll}
{\tt public void {\bf putAll}( {\tt java.util.Map } {\bf arg0} )
}%end signature
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\membername{remove}
{\tt public Object {\bf remove}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\membername{size}
{\tt public int {\bf size}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public Collection {\bf values}(  )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{SelectionType}{l195}{%
{\small An enum containing the possible selection algorithms
 that can be used. These can be set on a per-population 
 basis using PopulationParameters}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public final 
class 
SelectionType}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Enum}}
}}}
\startsubsubsection{Serializable Fields}{
\begin{itemize}
\item{
private Class \_impl\begin{itemize}\item{\vskip -.9ex }\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Fields}{
\begin{itemize}
\item{
public static final SelectionType PROPORTIONAL\begin{itemize}\item{\vskip -.9ex A proportional selection algorithm}\end{itemize}
}
\item{
public static final SelectionType TOURNAMENT\begin{itemize}\item{\vskip -.9ex A Tournament-based Selection selection Algorithm}\end{itemize}
}
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{eval}
{\tt public Class {\bf eval}(  )
\label{l728}\label{l729}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The implementing class. 
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static SelectionType {\bf valueOf}( {\tt java.lang.String } {\bf name} )
\label{l730}\label{l731}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\membername{values}
{\tt public static final SelectionType {\bf values}(  )
\label{l732}\label{l733}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
\startsubsubsection{Methods inherited from class {\tt java.lang.Enum}}{
\par{\small 
\refdefined{l113}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{clone}
{\tt protected final Object {\bf clone}(  )
}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\membername{compareTo}
{\tt public final int {\bf compareTo}( {\tt java.lang.Enum } {\bf arg0} )
}%end signature
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\membername{equals}
{\tt public final boolean {\bf equals}( {\tt java.lang.Object } {\bf arg0} )
}%end signature
}%end item
\divideents{getDeclaringClass}
\item{\vskip -1.9ex 
\membername{getDeclaringClass}
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\divideents{hashCode}
\item{\vskip -1.9ex 
\membername{hashCode}
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\divideents{name}
\item{\vskip -1.9ex 
\membername{name}
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\divideents{ordinal}
\item{\vskip -1.9ex 
\membername{ordinal}
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\membername{toString}
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\membername{valueOf}
{\tt public static Enum {\bf valueOf}( {\tt java.lang.Class } {\bf arg0},
{\tt java.lang.String } {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
}
\startsection{Class}{SelectProportional}{l630}{%
{\small Implements a proportional (Roulette Wheel) selection algorithm}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
SelectProportional}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
IndividualSelector}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{SelectProportional}
{\tt public {\bf SelectProportional}(  )
\label{l734}\label{l735}}%end signature
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{select}
{\tt public Population {\bf select}( {\tt net.parallaxed.bluejam.Population } {\bf pop},
{\tt int } {\bf numberOfIndividuals} )
\label{l736}\label{l737}}%end signature
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{SelectTournament}{l194}{%
{\small Performs a variant of tournament selection. Unlike the classic 
 tournament, this function is optimised to use FitnessStacked, 
 so the tournament takes place in two rounds. 
 
 The first round is negative selection, where the weakest are
 assigned proportionally greater probabilities, and a 
 roulette-wheel selection is made to knock out competitors.
 
 The second round is positive selection, where the individuals
 are evaluated again, and the largest score wins.
 
 Two are taken from each Tournament until the number of parents
 required for breeding are selected.
 
 This will still work on fitness methods other than FitnessStacked.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
SelectTournament}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
IndividualSelector}}
}}}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{getInstance}
{\tt public static final SelectTournament {\bf getInstance}(  )
\label{l738}\label{l739}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
An instance of SelectTournament 
}%end item
\end{itemize}
}%end item
\divideents{round1}
\item{\vskip -1.9ex 
\membername{round1}
{\tt protected void {\bf round1}( {\tt java.util.ArrayList } {\bf competitors},
{\tt int } {\bf firstRoundKnockouts} )
\label{l740}\label{l741}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Round 1 performs a negative selection favouring the worst
 individuals. A total of {\it firstRoundKnockouts} individuals are
 selected and the passed competitors list is whittled down.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt competitors} - The competitors in the tournament}
   \item{
\sld
{\tt firstRoundKnockouts} - The number of competitors to knock out in the first round.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{round2}
\item{\vskip -1.9ex 
\membername{round2}
{\tt protected ArrayList {\bf round2}( {\tt java.util.ArrayList } {\bf competitors} )
\label{l742}\label{l743}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Further compares the fitness of the individuals.
 
 This method is designed for FitnessStacked, but can still
 work on other fitness Functions - just becomes a 
 regular TournamentSelection from here on in (fittest one wins).
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt competitors} - The competitors.}
  \end{itemize}
}%end item
\item{{\bf Returns} - 
The winners. 
}%end item
\item{{\bf See Also}
  \begin{itemize}
   \item{{\tt net.parallaxed.bluejam.evolution.FitnessStacked} {\small 
\refdefined{l620}}%end \small
}%end item
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{select}
\item{\vskip -1.9ex 
\membername{select}
{\tt public Population {\bf select}( {\tt net.parallaxed.bluejam.Population } {\bf pop},
{\tt int } {\bf numberOfIndividuals} )
\label{l744}\label{l745}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$$\}$
 
 Satisfies the implementation of IndividualSelector.
 
 See the class documentation for more coverage on how we
 execute the selection.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
\startsection{Class}{TreeBreeder}{l631}{%
{\small TreeBreeder is the default implementation of the Breeder
 interface for recombining and mutating NoteTrees, given 
 an initial skeletal population.
 
 Unlike other algorithms, this is not a singleton, since 
 there may be more than one breeder available at any
 one time.
 
 TODO Check working implementation of other NoteSequence representations.}
\vskip .1in 
\startsubsubsection{Declaration}{
\fbox{\vbox{
\hbox{\vbox{\small public 
class 
TreeBreeder}}
\noindent\hbox{\vbox{{\bf extends} java.lang.Object}}
\noindent\hbox{\vbox{{\bf implements} 
Breeder}}
}}}
\startsubsubsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{TreeBreeder}
{\tt public {\bf TreeBreeder}(  )
\label{l746}\label{l747}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Instantiates a TreeBuilder trivially.
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{TreeBreeder}
\item{\vskip -1.9ex 
\membername{TreeBreeder}
{\tt public {\bf TreeBreeder}( {\tt int } {\bf maxBreedCycles},
{\tt double } {\bf crossoverProbability} )
\label{l748}\label{l749}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Instantiates a TreeBreeder with the passed parameters.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt maxBreedCycles} - }
   \item{
\sld
{\tt crossoverProbability} - }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\startsubsubsection{Methods}{
\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\membername{breed}
{\tt public void {\bf breed}( {\tt net.parallaxed.bluejam.Population } {\bf population} )
\label{l750}\label{l751}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
$\{$@inheritDoc$\}$
}%end item
  \end{itemize}
}
\end{itemize}
}%end item
\divideents{crossoverProbability}
\item{\vskip -1.9ex 
\membername{crossoverProbability}
{\tt public double {\bf crossoverProbability}(  )
\label{l752}\label{l753}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
A value between 0 and 1 for the probability of doing crossover on the individual. 
}%end item
\end{itemize}
}%end item
\divideents{crossoverProbability}
\item{\vskip -1.9ex 
\membername{crossoverProbability}
{\tt public void {\bf crossoverProbability}( {\tt double } {\bf probability} )
\label{l754}\label{l755}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
NOTE: Setting this variable also sets the probability for mutation
 in this breeder.
 
 Sets the probability of crossover (between 0 an 1). The inverse 
 of this value sets the probability for mutation. Setting this to a
 value less than 0.5 is not recommended.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt probability} - A value between 0-1 (inclusive).}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{maxBreedCycles}
\item{\vskip -1.9ex 
\membername{maxBreedCycles}
{\tt public int {\bf maxBreedCycles}(  )
\label{l756}\label{l757}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} - 
The maximum number of times we run breeding functions over any single or pair of individuals. 
}%end item
\end{itemize}
}%end item
\divideents{maxBreedCycles}
\item{\vskip -1.9ex 
\membername{maxBreedCycles}
{\tt public void {\bf maxBreedCycles}( {\tt int } {\bf cycles} )
\label{l758}\label{l759}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Sets the maximum number of times we run a breeding 
 process for each Individual pair. Default = 5.
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt cycles} - The number of times to runs}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{recombine}
\item{\vskip -1.9ex 
\membername{recombine}
{\tt public void {\bf recombine}( {\tt net.parallaxed.bluejam.NoteTree } {\bf nt1},
{\tt net.parallaxed.bluejam.NoteTree } {\bf nt2} )
\label{l760}\label{l761}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Usage}
  \begin{itemize}\isep
   \item{
Performs crossover on two passed NoteTrees in-situ. 
 
 This methods should receive two note trees that are
 to be crossed over. Nothing is returned, the trees are
 altered in-situ and should remain that way. If breeding
 NoteTrees through this method, always pass the clone().
}%end item
  \end{itemize}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt nt1} - A note tree to recombine}
   \item{
\sld
{\tt nt2} - The note tree to combine with.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\hide{inherited}{
}
}
}
}
\end{document}
